(function () {
    'use strict';

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, module) {
        return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var check = function (it) {
        return it && it.Math == Math && it;
    };

    // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
    var global_1 =
        // eslint-disable-next-line es/no-global-this -- safe
        check(typeof globalThis == 'object' && globalThis) ||
        check(typeof window == 'object' && window) ||
        // eslint-disable-next-line no-restricted-globals -- safe
        check(typeof self == 'object' && self) ||
        check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
        // eslint-disable-next-line no-new-func -- fallback
        (function () { return this; })() || Function('return this')();

    var fails = function (exec) {
        try {
            return !!exec();
        } catch (error) {
            return true;
        }
    };

    // Detect IE8's incomplete defineProperty implementation
    var descriptors = !fails(function () {
        // eslint-disable-next-line es/no-object-defineproperty -- required for testing
        return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
    });

    var $propertyIsEnumerable = {}.propertyIsEnumerable;
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

    // Nashorn ~ JDK8 bug
    var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

    // `Object.prototype.propertyIsEnumerable` method implementation
    // https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
    var f = NASHORN_BUG ? function propertyIsEnumerable(V) {
        var descriptor = getOwnPropertyDescriptor(this, V);
        return !!descriptor && descriptor.enumerable;
    } : $propertyIsEnumerable;

    var objectPropertyIsEnumerable = {
        f: f
    };

    var createPropertyDescriptor = function (bitmap, value) {
        return {
            enumerable: !(bitmap & 1),
            configurable: !(bitmap & 2),
            writable: !(bitmap & 4),
            value: value
        };
    };

    var toString = {}.toString;

    var classofRaw = function (it) {
        return toString.call(it).slice(8, -1);
    };

    var split = ''.split;

    // fallback for non-array-like ES3 and non-enumerable old V8 strings
    var indexedObject = fails(function () {
        // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
        // eslint-disable-next-line no-prototype-builtins -- safe
        return !Object('z').propertyIsEnumerable(0);
    }) ? function (it) {
        return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
    } : Object;

    // `RequireObjectCoercible` abstract operation
    // https://tc39.es/ecma262/#sec-requireobjectcoercible
    var requireObjectCoercible = function (it) {
        if (it == undefined) throw TypeError("Can't call method on " + it);
        return it;
    };

    // toObject with fallback for non-array-like ES3 strings



    var toIndexedObject = function (it) {
        return indexedObject(requireObjectCoercible(it));
    };

    // `IsCallable` abstract operation
    // https://tc39.es/ecma262/#sec-iscallable
    var isCallable = function (argument) {
        return typeof argument === 'function';
    };

    var isObject = function (it) {
        return typeof it === 'object' ? it !== null : isCallable(it);
    };

    var aFunction = function (argument) {
        return isCallable(argument) ? argument : undefined;
    };

    var getBuiltIn = function (namespace, method) {
        return arguments.length < 2 ? aFunction(global_1[namespace]) : global_1[namespace] && global_1[namespace][method];
    };

    var engineUserAgent = getBuiltIn('navigator', 'userAgent') || '';

    var process = global_1.process;
    var Deno = global_1.Deno;
    var versions = process && process.versions || Deno && Deno.version;
    var v8 = versions && versions.v8;
    var match, version;

    if (v8) {
        match = v8.split('.');
        version = match[0] < 4 ? 1 : match[0] + match[1];
    } else if (engineUserAgent) {
        match = engineUserAgent.match(/Edge\/(\d+)/);
        if (!match || match[1] >= 74) {
            match = engineUserAgent.match(/Chrome\/(\d+)/);
            if (match) version = match[1];
        }
    }

    var engineV8Version = version && +version;

    /* eslint-disable es/no-symbol -- required for testing */



    // eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
    var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
        var symbol = Symbol();
        // Chrome 38 Symbol has incorrect toString conversion
        // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
        return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
            // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
            !Symbol.sham && engineV8Version && engineV8Version < 41;
    });

    /* eslint-disable es/no-symbol -- required for testing */


    var useSymbolAsUid = nativeSymbol
        && !Symbol.sham
        && typeof Symbol.iterator == 'symbol';

    var isSymbol = useSymbolAsUid ? function (it) {
        return typeof it == 'symbol';
    } : function (it) {
        var $Symbol = getBuiltIn('Symbol');
        return isCallable($Symbol) && Object(it) instanceof $Symbol;
    };

    var tryToString = function (argument) {
        try {
            return String(argument);
        } catch (error) {
            return 'Object';
        }
    };

    // `Assert: IsCallable(argument) is true`
    var aCallable = function (argument) {
        if (isCallable(argument)) return argument;
        throw TypeError(tryToString(argument) + ' is not a function');
    };

    // `GetMethod` abstract operation
    // https://tc39.es/ecma262/#sec-getmethod
    var getMethod = function (V, P) {
        var func = V[P];
        return func == null ? undefined : aCallable(func);
    };

    // `OrdinaryToPrimitive` abstract operation
    // https://tc39.es/ecma262/#sec-ordinarytoprimitive
    var ordinaryToPrimitive = function (input, pref) {
        var fn, val;
        if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = fn.call(input))) return val;
        if (isCallable(fn = input.valueOf) && !isObject(val = fn.call(input))) return val;
        if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = fn.call(input))) return val;
        throw TypeError("Can't convert object to primitive value");
    };

    var isPure = false;

    var setGlobal = function (key, value) {
        try {
            // eslint-disable-next-line es/no-object-defineproperty -- safe
            Object.defineProperty(global_1, key, { value: value, configurable: true, writable: true });
        } catch (error) {
            global_1[key] = value;
        } return value;
    };

    var SHARED = '__core-js_shared__';
    var store = global_1[SHARED] || setGlobal(SHARED, {});

    var sharedStore = store;

    var shared = createCommonjsModule(function (module) {
        (module.exports = function (key, value) {
            return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
        })('versions', []).push({
            version: '3.18.3',
            mode: 'global',
            copyright: 'Â© 2021 Denis Pushkarev (zloirock.ru)'
        });
    });

    // `ToObject` abstract operation
    // https://tc39.es/ecma262/#sec-toobject
    var toObject = function (argument) {
        return Object(requireObjectCoercible(argument));
    };

    var hasOwnProperty = {}.hasOwnProperty;

    // `HasOwnProperty` abstract operation
    // https://tc39.es/ecma262/#sec-hasownproperty
    var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
        return hasOwnProperty.call(toObject(it), key);
    };

    var id = 0;
    var postfix = Math.random();

    var uid = function (key) {
        return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
    };

    var WellKnownSymbolsStore = shared('wks');
    var Symbol$1 = global_1.Symbol;
    var createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;

    var wellKnownSymbol = function (name) {
        if (!hasOwnProperty_1(WellKnownSymbolsStore, name) || !(nativeSymbol || typeof WellKnownSymbolsStore[name] == 'string')) {
            if (nativeSymbol && hasOwnProperty_1(Symbol$1, name)) {
                WellKnownSymbolsStore[name] = Symbol$1[name];
            } else {
                WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
            }
        } return WellKnownSymbolsStore[name];
    };

    var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

    // `ToPrimitive` abstract operation
    // https://tc39.es/ecma262/#sec-toprimitive
    var toPrimitive = function (input, pref) {
        if (!isObject(input) || isSymbol(input)) return input;
        var exoticToPrim = getMethod(input, TO_PRIMITIVE);
        var result;
        if (exoticToPrim) {
            if (pref === undefined) pref = 'default';
            result = exoticToPrim.call(input, pref);
            if (!isObject(result) || isSymbol(result)) return result;
            throw TypeError("Can't convert object to primitive value");
        }
        if (pref === undefined) pref = 'number';
        return ordinaryToPrimitive(input, pref);
    };

    // `ToPropertyKey` abstract operation
    // https://tc39.es/ecma262/#sec-topropertykey
    var toPropertyKey = function (argument) {
        var key = toPrimitive(argument, 'string');
        return isSymbol(key) ? key : String(key);
    };

    var document$1 = global_1.document;
    // typeof document.createElement is 'object' in old IE
    var EXISTS = isObject(document$1) && isObject(document$1.createElement);

    var documentCreateElement = function (it) {
        return EXISTS ? document$1.createElement(it) : {};
    };

    // Thank's IE8 for his funny defineProperty
    var ie8DomDefine = !descriptors && !fails(function () {
        // eslint-disable-next-line es/no-object-defineproperty -- requied for testing
        return Object.defineProperty(documentCreateElement('div'), 'a', {
            get: function () { return 7; }
        }).a != 7;
    });

    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

    // `Object.getOwnPropertyDescriptor` method
    // https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
    var f$1 = descriptors ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
        O = toIndexedObject(O);
        P = toPropertyKey(P);
        if (ie8DomDefine) try {
            return $getOwnPropertyDescriptor(O, P);
        } catch (error) { /* empty */ }
        if (hasOwnProperty_1(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
    };

    var objectGetOwnPropertyDescriptor = {
        f: f$1
    };

    // `Assert: Type(argument) is Object`
    var anObject = function (argument) {
        if (isObject(argument)) return argument;
        throw TypeError(String(argument) + ' is not an object');
    };

    // eslint-disable-next-line es/no-object-defineproperty -- safe
    var $defineProperty = Object.defineProperty;

    // `Object.defineProperty` method
    // https://tc39.es/ecma262/#sec-object.defineproperty
    var f$2 = descriptors ? $defineProperty : function defineProperty(O, P, Attributes) {
        anObject(O);
        P = toPropertyKey(P);
        anObject(Attributes);
        if (ie8DomDefine) try {
            return $defineProperty(O, P, Attributes);
        } catch (error) { /* empty */ }
        if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
        if ('value' in Attributes) O[P] = Attributes.value;
        return O;
    };

    var objectDefineProperty = {
        f: f$2
    };

    var createNonEnumerableProperty = descriptors ? function (object, key, value) {
        return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
    } : function (object, key, value) {
        object[key] = value;
        return object;
    };

    var functionToString = Function.toString;

    // this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
    if (!isCallable(sharedStore.inspectSource)) {
        sharedStore.inspectSource = function (it) {
            return functionToString.call(it);
        };
    }

    var inspectSource = sharedStore.inspectSource;

    var WeakMap$1 = global_1.WeakMap;

    var nativeWeakMap = isCallable(WeakMap$1) && /native code/.test(inspectSource(WeakMap$1));

    var keys = shared('keys');

    var sharedKey = function (key) {
        return keys[key] || (keys[key] = uid(key));
    };

    var hiddenKeys = {};

    var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
    var WeakMap$2 = global_1.WeakMap;
    var set, get, has;

    var enforce = function (it) {
        return has(it) ? get(it) : set(it, {});
    };

    var getterFor = function (TYPE) {
        return function (it) {
            var state;
            if (!isObject(it) || (state = get(it)).type !== TYPE) {
                throw TypeError('Incompatible receiver, ' + TYPE + ' required');
            } return state;
        };
    };

    if (nativeWeakMap || sharedStore.state) {
        var store$1 = sharedStore.state || (sharedStore.state = new WeakMap$2());
        var wmget = store$1.get;
        var wmhas = store$1.has;
        var wmset = store$1.set;
        set = function (it, metadata) {
            if (wmhas.call(store$1, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
            metadata.facade = it;
            wmset.call(store$1, it, metadata);
            return metadata;
        };
        get = function (it) {
            return wmget.call(store$1, it) || {};
        };
        has = function (it) {
            return wmhas.call(store$1, it);
        };
    } else {
        var STATE = sharedKey('state');
        hiddenKeys[STATE] = true;
        set = function (it, metadata) {
            if (hasOwnProperty_1(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
            metadata.facade = it;
            createNonEnumerableProperty(it, STATE, metadata);
            return metadata;
        };
        get = function (it) {
            return hasOwnProperty_1(it, STATE) ? it[STATE] : {};
        };
        has = function (it) {
            return hasOwnProperty_1(it, STATE);
        };
    }

    var internalState = {
        set: set,
        get: get,
        has: has,
        enforce: enforce,
        getterFor: getterFor
    };

    var FunctionPrototype = Function.prototype;
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    var getDescriptor = descriptors && Object.getOwnPropertyDescriptor;

    var EXISTS$1 = hasOwnProperty_1(FunctionPrototype, 'name');
    // additional protection from minified / mangled / dropped function names
    var PROPER = EXISTS$1 && (function something() { /* empty */ }).name === 'something';
    var CONFIGURABLE = EXISTS$1 && (!descriptors || (descriptors && getDescriptor(FunctionPrototype, 'name').configurable));

    var functionName = {
        EXISTS: EXISTS$1,
        PROPER: PROPER,
        CONFIGURABLE: CONFIGURABLE
    };

    var redefine = createCommonjsModule(function (module) {
        var CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;

        var getInternalState = internalState.get;
        var enforceInternalState = internalState.enforce;
        var TEMPLATE = String(String).split('String');

        (module.exports = function (O, key, value, options) {
            var unsafe = options ? !!options.unsafe : false;
            var simple = options ? !!options.enumerable : false;
            var noTargetGet = options ? !!options.noTargetGet : false;
            var name = options && options.name !== undefined ? options.name : key;
            var state;
            if (isCallable(value)) {
                if (String(name).slice(0, 7) === 'Symbol(') {
                    name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
                }
                if (!hasOwnProperty_1(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
                    createNonEnumerableProperty(value, 'name', name);
                }
                state = enforceInternalState(value);
                if (!state.source) {
                    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
                }
            }
            if (O === global_1) {
                if (simple) O[key] = value;
                else setGlobal(key, value);
                return;
            } else if (!unsafe) {
                delete O[key];
            } else if (!noTargetGet && O[key]) {
                simple = true;
            }
            if (simple) O[key] = value;
            else createNonEnumerableProperty(O, key, value);
            // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
        })(Function.prototype, 'toString', function toString() {
            return isCallable(this) && getInternalState(this).source || inspectSource(this);
        });
    });

    var ceil = Math.ceil;
    var floor = Math.floor;

    // `ToIntegerOrInfinity` abstract operation
    // https://tc39.es/ecma262/#sec-tointegerorinfinity
    var toIntegerOrInfinity = function (argument) {
        var number = +argument;
        // eslint-disable-next-line no-self-compare -- safe
        return number !== number || number === 0 ? 0 : (number > 0 ? floor : ceil)(number);
    };

    var max = Math.max;
    var min = Math.min;

    // Helper for a popular repeating case of the spec:
    // Let integer be ? ToInteger(index).
    // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
    var toAbsoluteIndex = function (index, length) {
        var integer = toIntegerOrInfinity(index);
        return integer < 0 ? max(integer + length, 0) : min(integer, length);
    };

    var min$1 = Math.min;

    // `ToLength` abstract operation
    // https://tc39.es/ecma262/#sec-tolength
    var toLength = function (argument) {
        return argument > 0 ? min$1(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
    };

    // `LengthOfArrayLike` abstract operation
    // https://tc39.es/ecma262/#sec-lengthofarraylike
    var lengthOfArrayLike = function (obj) {
        return toLength(obj.length);
    };

    // `Array.prototype.{ indexOf, includes }` methods implementation
    var createMethod = function (IS_INCLUDES) {
        return function ($this, el, fromIndex) {
            var O = toIndexedObject($this);
            var length = lengthOfArrayLike(O);
            var index = toAbsoluteIndex(fromIndex, length);
            var value;
            // Array#includes uses SameValueZero equality algorithm
            // eslint-disable-next-line no-self-compare -- NaN check
            if (IS_INCLUDES && el != el) while (length > index) {
                value = O[index++];
                // eslint-disable-next-line no-self-compare -- NaN check
                if (value != value) return true;
                // Array#indexOf ignores holes, Array#includes - not
            } else for (; length > index; index++) {
                if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
            } return !IS_INCLUDES && -1;
        };
    };

    var arrayIncludes = {
        // `Array.prototype.includes` method
        // https://tc39.es/ecma262/#sec-array.prototype.includes
        includes: createMethod(true),
        // `Array.prototype.indexOf` method
        // https://tc39.es/ecma262/#sec-array.prototype.indexof
        indexOf: createMethod(false)
    };

    var indexOf = arrayIncludes.indexOf;


    var objectKeysInternal = function (object, names) {
        var O = toIndexedObject(object);
        var i = 0;
        var result = [];
        var key;
        for (key in O) !hasOwnProperty_1(hiddenKeys, key) && hasOwnProperty_1(O, key) && result.push(key);
        // Don't enum bug & hidden keys
        while (names.length > i) if (hasOwnProperty_1(O, key = names[i++])) {
            ~indexOf(result, key) || result.push(key);
        }
        return result;
    };

    // IE8- don't enum bug keys
    var enumBugKeys = [
        'constructor',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'toLocaleString',
        'toString',
        'valueOf'
    ];

    var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype');

    // `Object.getOwnPropertyNames` method
    // https://tc39.es/ecma262/#sec-object.getownpropertynames
    // eslint-disable-next-line es/no-object-getownpropertynames -- safe
    var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
        return objectKeysInternal(O, hiddenKeys$1);
    };

    var objectGetOwnPropertyNames = {
        f: f$3
    };

    // eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
    var f$4 = Object.getOwnPropertySymbols;

    var objectGetOwnPropertySymbols = {
        f: f$4
    };

    // all object keys, includes non-enumerable and symbols
    var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
        var keys = objectGetOwnPropertyNames.f(anObject(it));
        var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
        return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
    };

    var copyConstructorProperties = function (target, source) {
        var keys = ownKeys(source);
        var defineProperty = objectDefineProperty.f;
        var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (!hasOwnProperty_1(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
        }
    };

    var replacement = /#|\.prototype\./;

    var isForced = function (feature, detection) {
        var value = data[normalize(feature)];
        return value == POLYFILL ? true
            : value == NATIVE ? false
                : isCallable(detection) ? fails(detection)
                    : !!detection;
    };

    var normalize = isForced.normalize = function (string) {
        return String(string).replace(replacement, '.').toLowerCase();
    };

    var data = isForced.data = {};
    var NATIVE = isForced.NATIVE = 'N';
    var POLYFILL = isForced.POLYFILL = 'P';

    var isForced_1 = isForced;

    var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;






    /*
      options.target      - name of the target object
      options.global      - target is the global object
      options.stat        - export as static methods of target
      options.proto       - export as prototype methods of target
      options.real        - real prototype method for the `pure` version
      options.forced      - export even if the native feature is available
      options.bind        - bind methods to the target, required for the `pure` version
      options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
      options.unsafe      - use the simple assignment of property instead of delete + defineProperty
      options.sham        - add a flag to not completely full polyfills
      options.enumerable  - export as enumerable property
      options.noTargetGet - prevent calling a getter on target
      options.name        - the .name of the function if it does not match the key
    */
    var _export = function (options, source) {
        var TARGET = options.target;
        var GLOBAL = options.global;
        var STATIC = options.stat;
        var FORCED, target, key, targetProperty, sourceProperty, descriptor;
        if (GLOBAL) {
            target = global_1;
        } else if (STATIC) {
            target = global_1[TARGET] || setGlobal(TARGET, {});
        } else {
            target = (global_1[TARGET] || {}).prototype;
        }
        if (target) for (key in source) {
            sourceProperty = source[key];
            if (options.noTargetGet) {
                descriptor = getOwnPropertyDescriptor$1(target, key);
                targetProperty = descriptor && descriptor.value;
            } else targetProperty = target[key];
            FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
            // contained in target
            if (!FORCED && targetProperty !== undefined) {
                if (typeof sourceProperty === typeof targetProperty) continue;
                copyConstructorProperties(sourceProperty, targetProperty);
            }
            // add a flag to not completely full polyfills
            if (options.sham || (targetProperty && targetProperty.sham)) {
                createNonEnumerableProperty(sourceProperty, 'sham', true);
            }
            // extend global
            redefine(target, key, sourceProperty, options);
        }
    };

    // `Object.keys` method
    // https://tc39.es/ecma262/#sec-object.keys
    // eslint-disable-next-line es/no-object-keys -- safe
    var objectKeys = Object.keys || function keys(O) {
        return objectKeysInternal(O, enumBugKeys);
    };

    // eslint-disable-next-line es/no-object-assign -- safe
    var $assign = Object.assign;
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    var defineProperty = Object.defineProperty;

    // `Object.assign` method
    // https://tc39.es/ecma262/#sec-object.assign
    var objectAssign = !$assign || fails(function () {
        // should have correct order of operations (Edge bug)
        if (descriptors && $assign({ b: 1 }, $assign(defineProperty({}, 'a', {
            enumerable: true,
            get: function () {
                defineProperty(this, 'b', {
                    value: 3,
                    enumerable: false
                });
            }
        }), { b: 2 })).b !== 1) return true;
        // should work with symbols and should have deterministic property order (V8 bug)
        var A = {};
        var B = {};
        // eslint-disable-next-line es/no-symbol -- safe
        var symbol = Symbol();
        var alphabet = 'abcdefghijklmnopqrst';
        A[symbol] = 7;
        alphabet.split('').forEach(function (chr) { B[chr] = chr; });
        return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join('') != alphabet;
    }) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`
        var T = toObject(target);
        var argumentsLength = arguments.length;
        var index = 1;
        var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
        var propertyIsEnumerable = objectPropertyIsEnumerable.f;
        while (argumentsLength > index) {
            var S = indexedObject(arguments[index++]);
            var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
            var length = keys.length;
            var j = 0;
            var key;
            while (length > j) {
                key = keys[j++];
                if (!descriptors || propertyIsEnumerable.call(S, key)) T[key] = S[key];
            }
        } return T;
    } : $assign;

    // `Object.assign` method
    // https://tc39.es/ecma262/#sec-object.assign
    // eslint-disable-next-line es/no-object-assign -- required for testing
    _export({ target: 'Object', stat: true, forced: Object.assign !== objectAssign }, {
        assign: objectAssign
    });

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }

    function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
    }

    function _newArrowCheck(innerThis, boundThis) {
        if (innerThis !== boundThis) {
            throw new TypeError("Cannot instantiate an arrow function");
        }
    }

    function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }

    function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }

    function _iterableToArray(iter) {
        if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }

    function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }

    function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;

        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

        return arr2;
    }

    function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    // iterable DOM collections
    // flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
    var domIterables = {
        CSSRuleList: 0,
        CSSStyleDeclaration: 0,
        CSSValueList: 0,
        ClientRectList: 0,
        DOMRectList: 0,
        DOMStringList: 0,
        DOMTokenList: 1,
        DataTransferItemList: 0,
        FileList: 0,
        HTMLAllCollection: 0,
        HTMLCollection: 0,
        HTMLFormElement: 0,
        HTMLSelectElement: 0,
        MediaList: 0,
        MimeTypeArray: 0,
        NamedNodeMap: 0,
        NodeList: 1,
        PaintRequestList: 0,
        Plugin: 0,
        PluginArray: 0,
        SVGLengthList: 0,
        SVGNumberList: 0,
        SVGPathSegList: 0,
        SVGPointList: 0,
        SVGStringList: 0,
        SVGTransformList: 0,
        SourceBufferList: 0,
        StyleSheetList: 0,
        TextTrackCueList: 0,
        TextTrackList: 0,
        TouchList: 0
    };

    // in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`


    var classList = documentCreateElement('span').classList;
    var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;

    var domTokenListPrototype = DOMTokenListPrototype === Object.prototype ? undefined : DOMTokenListPrototype;

    // optional / simple context binding
    var functionBindContext = function (fn, that, length) {
        aCallable(fn);
        if (that === undefined) return fn;
        switch (length) {
            case 0: return function () {
                return fn.call(that);
            };
            case 1: return function (a) {
                return fn.call(that, a);
            };
            case 2: return function (a, b) {
                return fn.call(that, a, b);
            };
            case 3: return function (a, b, c) {
                return fn.call(that, a, b, c);
            };
        }
        return function (/* ...args */) {
            return fn.apply(that, arguments);
        };
    };

    // `IsArray` abstract operation
    // https://tc39.es/ecma262/#sec-isarray
    // eslint-disable-next-line es/no-array-isarray -- safe
    var isArray = Array.isArray || function isArray(argument) {
        return classofRaw(argument) == 'Array';
    };

    var TO_STRING_TAG = wellKnownSymbol('toStringTag');
    var test = {};

    test[TO_STRING_TAG] = 'z';

    var toStringTagSupport = String(test) === '[object z]';

    var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');
    // ES3 wrong here
    var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

    // fallback for IE11 Script Access Denied error
    var tryGet = function (it, key) {
        try {
            return it[key];
        } catch (error) { /* empty */ }
    };

    // getting tag from ES6+ `Object.prototype.toString`
    var classof = toStringTagSupport ? classofRaw : function (it) {
        var O, tag, result;
        return it === undefined ? 'Undefined' : it === null ? 'Null'
            // @@toStringTag case
            : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$1)) == 'string' ? tag
                // builtinTag case
                : CORRECT_ARGUMENTS ? classofRaw(O)
                    // ES3 arguments fallback
                    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
    };

    var empty = [];
    var construct = getBuiltIn('Reflect', 'construct');
    var constructorRegExp = /^\s*(?:class|function)\b/;
    var exec = constructorRegExp.exec;
    var INCORRECT_TO_STRING = !constructorRegExp.exec(function () { /* empty */ });

    var isConstructorModern = function (argument) {
        if (!isCallable(argument)) return false;
        try {
            construct(Object, empty, argument);
            return true;
        } catch (error) {
            return false;
        }
    };

    var isConstructorLegacy = function (argument) {
        if (!isCallable(argument)) return false;
        switch (classof(argument)) {
            case 'AsyncFunction':
            case 'GeneratorFunction':
            case 'AsyncGeneratorFunction': return false;
            // we can't check .prototype since constructors produced by .bind haven't it
        } return INCORRECT_TO_STRING || !!exec.call(constructorRegExp, inspectSource(argument));
    };

    // `IsConstructor` abstract operation
    // https://tc39.es/ecma262/#sec-isconstructor
    var isConstructor = !construct || fails(function () {
        var called;
        return isConstructorModern(isConstructorModern.call)
            || !isConstructorModern(Object)
            || !isConstructorModern(function () { called = true; })
            || called;
    }) ? isConstructorLegacy : isConstructorModern;

    var SPECIES = wellKnownSymbol('species');

    // a part of `ArraySpeciesCreate` abstract operation
    // https://tc39.es/ecma262/#sec-arrayspeciescreate
    var arraySpeciesConstructor = function (originalArray) {
        var C;
        if (isArray(originalArray)) {
            C = originalArray.constructor;
            // cross-realm fallback
            if (isConstructor(C) && (C === Array || isArray(C.prototype))) C = undefined;
            else if (isObject(C)) {
                C = C[SPECIES];
                if (C === null) C = undefined;
            }
        } return C === undefined ? Array : C;
    };

    // `ArraySpeciesCreate` abstract operation
    // https://tc39.es/ecma262/#sec-arrayspeciescreate
    var arraySpeciesCreate = function (originalArray, length) {
        return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
    };

    var push = [].push;

    // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
    var createMethod$1 = function (TYPE) {
        var IS_MAP = TYPE == 1;
        var IS_FILTER = TYPE == 2;
        var IS_SOME = TYPE == 3;
        var IS_EVERY = TYPE == 4;
        var IS_FIND_INDEX = TYPE == 6;
        var IS_FILTER_REJECT = TYPE == 7;
        var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
        return function ($this, callbackfn, that, specificCreate) {
            var O = toObject($this);
            var self = indexedObject(O);
            var boundFunction = functionBindContext(callbackfn, that, 3);
            var length = lengthOfArrayLike(self);
            var index = 0;
            var create = specificCreate || arraySpeciesCreate;
            var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
            var value, result;
            for (; length > index; index++) if (NO_HOLES || index in self) {
                value = self[index];
                result = boundFunction(value, index, O);
                if (TYPE) {
                    if (IS_MAP) target[index] = result; // map
                    else if (result) switch (TYPE) {
                        case 3: return true;              // some
                        case 5: return value;             // find
                        case 6: return index;             // findIndex
                        case 2: push.call(target, value); // filter
                    } else switch (TYPE) {
                        case 4: return false;             // every
                        case 7: push.call(target, value); // filterReject
                    }
                }
            }
            return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
        };
    };

    var arrayIteration = {
        // `Array.prototype.forEach` method
        // https://tc39.es/ecma262/#sec-array.prototype.foreach
        forEach: createMethod$1(0),
        // `Array.prototype.map` method
        // https://tc39.es/ecma262/#sec-array.prototype.map
        map: createMethod$1(1),
        // `Array.prototype.filter` method
        // https://tc39.es/ecma262/#sec-array.prototype.filter
        filter: createMethod$1(2),
        // `Array.prototype.some` method
        // https://tc39.es/ecma262/#sec-array.prototype.some
        some: createMethod$1(3),
        // `Array.prototype.every` method
        // https://tc39.es/ecma262/#sec-array.prototype.every
        every: createMethod$1(4),
        // `Array.prototype.find` method
        // https://tc39.es/ecma262/#sec-array.prototype.find
        find: createMethod$1(5),
        // `Array.prototype.findIndex` method
        // https://tc39.es/ecma262/#sec-array.prototype.findIndex
        findIndex: createMethod$1(6),
        // `Array.prototype.filterReject` method
        // https://github.com/tc39/proposal-array-filtering
        filterReject: createMethod$1(7)
    };

    var arrayMethodIsStrict = function (METHOD_NAME, argument) {
        var method = [][METHOD_NAME];
        return !!method && fails(function () {
            // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing
            method.call(null, argument || function () { throw 1; }, 1);
        });
    };

    var $forEach = arrayIteration.forEach;


    var STRICT_METHOD = arrayMethodIsStrict('forEach');

    // `Array.prototype.forEach` method implementation
    // https://tc39.es/ecma262/#sec-array.prototype.foreach
    var arrayForEach = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */) {
        return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        // eslint-disable-next-line es/no-array-prototype-foreach -- safe
    } : [].forEach;

    var handlePrototype = function (CollectionPrototype) {
        // some Chrome versions have non-configurable methods on DOMTokenList
        if (CollectionPrototype && CollectionPrototype.forEach !== arrayForEach) try {
            createNonEnumerableProperty(CollectionPrototype, 'forEach', arrayForEach);
        } catch (error) {
            CollectionPrototype.forEach = arrayForEach;
        }
    };

    for (var COLLECTION_NAME in domIterables) {
        if (domIterables[COLLECTION_NAME]) {
            handlePrototype(global_1[COLLECTION_NAME] && global_1[COLLECTION_NAME].prototype);
        }
    }

    handlePrototype(domTokenListPrototype);

    // `Object.prototype.toString` method implementation
    // https://tc39.es/ecma262/#sec-object.prototype.tostring
    var objectToString = toStringTagSupport ? {}.toString : function toString() {
        return '[object ' + classof(this) + ']';
    };

    // `Object.prototype.toString` method
    // https://tc39.es/ecma262/#sec-object.prototype.tostring
    if (!toStringTagSupport) {
        redefine(Object.prototype, 'toString', objectToString, { unsafe: true });
    }

    var nativePromiseConstructor = global_1.Promise;

    var redefineAll = function (target, src, options) {
        for (var key in src) redefine(target, key, src[key], options);
        return target;
    };

    var aPossiblePrototype = function (argument) {
        if (typeof argument === 'object' || isCallable(argument)) return argument;
        throw TypeError("Can't set " + String(argument) + ' as a prototype');
    };

    /* eslint-disable no-proto -- safe */



    // `Object.setPrototypeOf` method
    // https://tc39.es/ecma262/#sec-object.setprototypeof
    // Works with __proto__ only. Old v8 can't work with null proto objects.
    // eslint-disable-next-line es/no-object-setprototypeof -- safe
    var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
        var CORRECT_SETTER = false;
        var test = {};
        var setter;
        try {
            // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
            setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
            setter.call(test, []);
            CORRECT_SETTER = test instanceof Array;
        } catch (error) { /* empty */ }
        return function setPrototypeOf(O, proto) {
            anObject(O);
            aPossiblePrototype(proto);
            if (CORRECT_SETTER) setter.call(O, proto);
            else O.__proto__ = proto;
            return O;
        };
    }() : undefined);

    var defineProperty$1 = objectDefineProperty.f;



    var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');

    var setToStringTag = function (it, TAG, STATIC) {
        if (it && !hasOwnProperty_1(it = STATIC ? it : it.prototype, TO_STRING_TAG$2)) {
            defineProperty$1(it, TO_STRING_TAG$2, { configurable: true, value: TAG });
        }
    };

    var SPECIES$1 = wellKnownSymbol('species');

    var setSpecies = function (CONSTRUCTOR_NAME) {
        var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
        var defineProperty = objectDefineProperty.f;

        if (descriptors && Constructor && !Constructor[SPECIES$1]) {
            defineProperty(Constructor, SPECIES$1, {
                configurable: true,
                get: function () { return this; }
            });
        }
    };

    var anInstance = function (it, Constructor, name) {
        if (it instanceof Constructor) return it;
        throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
    };

    var iterators = {};

    var ITERATOR = wellKnownSymbol('iterator');
    var ArrayPrototype = Array.prototype;

    // check on default Array iterator
    var isArrayIteratorMethod = function (it) {
        return it !== undefined && (iterators.Array === it || ArrayPrototype[ITERATOR] === it);
    };

    var ITERATOR$1 = wellKnownSymbol('iterator');

    var getIteratorMethod = function (it) {
        if (it != undefined) return getMethod(it, ITERATOR$1)
            || getMethod(it, '@@iterator')
            || iterators[classof(it)];
    };

    var getIterator = function (argument, usingIterator) {
        var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
        if (aCallable(iteratorMethod)) return anObject(iteratorMethod.call(argument));
        throw TypeError(String(argument) + ' is not iterable');
    };

    var iteratorClose = function (iterator, kind, value) {
        var innerResult, innerError;
        anObject(iterator);
        try {
            innerResult = getMethod(iterator, 'return');
            if (!innerResult) {
                if (kind === 'throw') throw value;
                return value;
            }
            innerResult = innerResult.call(iterator);
        } catch (error) {
            innerError = true;
            innerResult = error;
        }
        if (kind === 'throw') throw value;
        if (innerError) throw innerResult;
        anObject(innerResult);
        return value;
    };

    var Result = function (stopped, result) {
        this.stopped = stopped;
        this.result = result;
    };

    var iterate = function (iterable, unboundFunction, options) {
        var that = options && options.that;
        var AS_ENTRIES = !!(options && options.AS_ENTRIES);
        var IS_ITERATOR = !!(options && options.IS_ITERATOR);
        var INTERRUPTED = !!(options && options.INTERRUPTED);
        var fn = functionBindContext(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);
        var iterator, iterFn, index, length, result, next, step;

        var stop = function (condition) {
            if (iterator) iteratorClose(iterator, 'normal', condition);
            return new Result(true, condition);
        };

        var callFn = function (value) {
            if (AS_ENTRIES) {
                anObject(value);
                return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
            } return INTERRUPTED ? fn(value, stop) : fn(value);
        };

        if (IS_ITERATOR) {
            iterator = iterable;
        } else {
            iterFn = getIteratorMethod(iterable);
            if (!iterFn) throw TypeError(String(iterable) + ' is not iterable');
            // optimisation for array iterators
            if (isArrayIteratorMethod(iterFn)) {
                for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
                    result = callFn(iterable[index]);
                    if (result && result instanceof Result) return result;
                } return new Result(false);
            }
            iterator = getIterator(iterable, iterFn);
        }

        next = iterator.next;
        while (!(step = next.call(iterator)).done) {
            try {
                result = callFn(step.value);
            } catch (error) {
                iteratorClose(iterator, 'throw', error);
            }
            if (typeof result == 'object' && result && result instanceof Result) return result;
        } return new Result(false);
    };

    var ITERATOR$2 = wellKnownSymbol('iterator');
    var SAFE_CLOSING = false;

    try {
        var called = 0;
        var iteratorWithReturn = {
            next: function () {
                return { done: !!called++ };
            },
            'return': function () {
                SAFE_CLOSING = true;
            }
        };
        iteratorWithReturn[ITERATOR$2] = function () {
            return this;
        };
    } catch (error) { /* empty */ }

    var checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
        if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
        var ITERATION_SUPPORT = false;
        try {
            var object = {};
            object[ITERATOR$2] = function () {
                return {
                    next: function () {
                        return { done: ITERATION_SUPPORT = true };
                    }
                };
            };
            exec(object);
        } catch (error) { /* empty */ }
        return ITERATION_SUPPORT;
    };

    // `Assert: IsConstructor(argument) is true`
    var aConstructor = function (argument) {
        if (isConstructor(argument)) return argument;
        throw TypeError(tryToString(argument) + ' is not a constructor');
    };

    var SPECIES$2 = wellKnownSymbol('species');

    // `SpeciesConstructor` abstract operation
    // https://tc39.es/ecma262/#sec-speciesconstructor
    var speciesConstructor = function (O, defaultConstructor) {
        var C = anObject(O).constructor;
        var S;
        return C === undefined || (S = anObject(C)[SPECIES$2]) == undefined ? defaultConstructor : aConstructor(S);
    };

    var html = getBuiltIn('document', 'documentElement');

    var engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(engineUserAgent);

    var engineIsNode = classofRaw(global_1.process) == 'process';

    var set$2 = global_1.setImmediate;
    var clear = global_1.clearImmediate;
    var process$1 = global_1.process;
    var MessageChannel = global_1.MessageChannel;
    var Dispatch = global_1.Dispatch;
    var counter = 0;
    var queue = {};
    var ONREADYSTATECHANGE = 'onreadystatechange';
    var location, defer, channel, port;

    try {
        // Deno throws a ReferenceError on `location` access without `--location` flag
        location = global_1.location;
    } catch (error) { /* empty */ }

    var run = function (id) {
        // eslint-disable-next-line no-prototype-builtins -- safe
        if (queue.hasOwnProperty(id)) {
            var fn = queue[id];
            delete queue[id];
            fn();
        }
    };

    var runner = function (id) {
        return function () {
            run(id);
        };
    };

    var listener = function (event) {
        run(event.data);
    };

    var post = function (id) {
        // old engines have not location.origin
        global_1.postMessage(String(id), location.protocol + '//' + location.host);
    };

    // Node.js 0.9+ & IE10+ has setImmediate, otherwise:
    if (!set$2 || !clear) {
        set$2 = function setImmediate(fn) {
            var args = [];
            var argumentsLength = arguments.length;
            var i = 1;
            while (argumentsLength > i) args.push(arguments[i++]);
            queue[++counter] = function () {
                // eslint-disable-next-line no-new-func -- spec requirement
                (isCallable(fn) ? fn : Function(fn)).apply(undefined, args);
            };
            defer(counter);
            return counter;
        };
        clear = function clearImmediate(id) {
            delete queue[id];
        };
        // Node.js 0.8-
        if (engineIsNode) {
            defer = function (id) {
                process$1.nextTick(runner(id));
            };
            // Sphere (JS game engine) Dispatch API
        } else if (Dispatch && Dispatch.now) {
            defer = function (id) {
                Dispatch.now(runner(id));
            };
            // Browsers with MessageChannel, includes WebWorkers
            // except iOS - https://github.com/zloirock/core-js/issues/624
        } else if (MessageChannel && !engineIsIos) {
            channel = new MessageChannel();
            port = channel.port2;
            channel.port1.onmessage = listener;
            defer = functionBindContext(port.postMessage, port, 1);
            // Browsers with postMessage, skip WebWorkers
            // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
        } else if (
            global_1.addEventListener &&
            isCallable(global_1.postMessage) &&
            !global_1.importScripts &&
            location && location.protocol !== 'file:' &&
            !fails(post)
        ) {
            defer = post;
            global_1.addEventListener('message', listener, false);
            // IE8-
        } else if (ONREADYSTATECHANGE in documentCreateElement('script')) {
            defer = function (id) {
                html.appendChild(documentCreateElement('script'))[ONREADYSTATECHANGE] = function () {
                    html.removeChild(this);
                    run(id);
                };
            };
            // Rest old browsers
        } else {
            defer = function (id) {
                setTimeout(runner(id), 0);
            };
        }
    }

    var task = {
        set: set$2,
        clear: clear
    };

    var engineIsIosPebble = /ipad|iphone|ipod/i.test(engineUserAgent) && global_1.Pebble !== undefined;

    var engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(engineUserAgent);

    var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
    var macrotask = task.set;





    var MutationObserver = global_1.MutationObserver || global_1.WebKitMutationObserver;
    var document$2 = global_1.document;
    var process$2 = global_1.process;
    var Promise$1 = global_1.Promise;
    // Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
    var queueMicrotaskDescriptor = getOwnPropertyDescriptor$2(global_1, 'queueMicrotask');
    var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

    var flush, head, last, notify, toggle, node, promise, then;

    // modern engines have queueMicrotask method
    if (!queueMicrotask) {
        flush = function () {
            var parent, fn;
            if (engineIsNode && (parent = process$2.domain)) parent.exit();
            while (head) {
                fn = head.fn;
                head = head.next;
                try {
                    fn();
                } catch (error) {
                    if (head) notify();
                    else last = undefined;
                    throw error;
                }
            } last = undefined;
            if (parent) parent.enter();
        };

        // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
        // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
        if (!engineIsIos && !engineIsNode && !engineIsWebosWebkit && MutationObserver && document$2) {
            toggle = true;
            node = document$2.createTextNode('');
            new MutationObserver(flush).observe(node, { characterData: true });
            notify = function () {
                node.data = toggle = !toggle;
            };
            // environments with maybe non-completely correct, but existent Promise
        } else if (!engineIsIosPebble && Promise$1 && Promise$1.resolve) {
            // Promise.resolve without an argument throws an error in LG WebOS 2
            promise = Promise$1.resolve(undefined);
            // workaround of WebKit ~ iOS Safari 10.1 bug
            promise.constructor = Promise$1;
            then = promise.then;
            notify = function () {
                then.call(promise, flush);
            };
            // Node.js without promises
        } else if (engineIsNode) {
            notify = function () {
                process$2.nextTick(flush);
            };
            // for other environments - macrotask based on:
            // - setImmediate
            // - MessageChannel
            // - window.postMessag
            // - onreadystatechange
            // - setTimeout
        } else {
            notify = function () {
                // strange IE + webpack dev server bug - use .call(global)
                macrotask.call(global_1, flush);
            };
        }
    }

    var microtask = queueMicrotask || function (fn) {
        var task$$1 = { fn: fn, next: undefined };
        if (last) last.next = task$$1;
        if (!head) {
            head = task$$1;
            notify();
        } last = task$$1;
    };

    var PromiseCapability = function (C) {
        var resolve, reject;
        this.promise = new C(function ($$resolve, $$reject) {
            if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
            resolve = $$resolve;
            reject = $$reject;
        });
        this.resolve = aCallable(resolve);
        this.reject = aCallable(reject);
    };

    // `NewPromiseCapability` abstract operation
    // https://tc39.es/ecma262/#sec-newpromisecapability
    var f$5 = function (C) {
        return new PromiseCapability(C);
    };

    var newPromiseCapability = {
        f: f$5
    };

    var promiseResolve = function (C, x) {
        anObject(C);
        if (isObject(x) && x.constructor === C) return x;
        var promiseCapability = newPromiseCapability.f(C);
        var resolve = promiseCapability.resolve;
        resolve(x);
        return promiseCapability.promise;
    };

    var hostReportErrors = function (a, b) {
        var console = global_1.console;
        if (console && console.error) {
            arguments.length === 1 ? console.error(a) : console.error(a, b);
        }
    };

    var perform = function (exec) {
        try {
            return { error: false, value: exec() };
        } catch (error) {
            return { error: true, value: error };
        }
    };

    var engineIsBrowser = typeof window == 'object';

    var task$1 = task.set;












    var SPECIES$3 = wellKnownSymbol('species');
    var PROMISE = 'Promise';
    var getInternalState = internalState.get;
    var setInternalState = internalState.set;
    var getInternalPromiseState = internalState.getterFor(PROMISE);
    var NativePromisePrototype = nativePromiseConstructor && nativePromiseConstructor.prototype;
    var PromiseConstructor = nativePromiseConstructor;
    var PromiseConstructorPrototype = NativePromisePrototype;
    var TypeError$1 = global_1.TypeError;
    var document$3 = global_1.document;
    var process$3 = global_1.process;
    var newPromiseCapability$1 = newPromiseCapability.f;
    var newGenericPromiseCapability = newPromiseCapability$1;
    var DISPATCH_EVENT = !!(document$3 && document$3.createEvent && global_1.dispatchEvent);
    var NATIVE_REJECTION_EVENT = isCallable(global_1.PromiseRejectionEvent);
    var UNHANDLED_REJECTION = 'unhandledrejection';
    var REJECTION_HANDLED = 'rejectionhandled';
    var PENDING = 0;
    var FULFILLED = 1;
    var REJECTED = 2;
    var HANDLED = 1;
    var UNHANDLED = 2;
    var SUBCLASSING = false;
    var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

    var FORCED = isForced_1(PROMISE, function () {
        var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(PromiseConstructor);
        var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(PromiseConstructor);
        // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
        // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
        // We can't detect it synchronously, so just check versions
        if (!GLOBAL_CORE_JS_PROMISE && engineV8Version === 66) return true;
        // We need Promise#finally in the pure version for preventing prototype pollution
        if (isPure && !PromiseConstructorPrototype['finally']) return true;
        // We can't use @@species feature detection in V8 since it causes
        // deoptimization and performance degradation
        // https://github.com/zloirock/core-js/issues/679
        if (engineV8Version >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false;
        // Detect correctness of subclassing with @@species support
        var promise = new PromiseConstructor(function (resolve) { resolve(1); });
        var FakePromise = function (exec) {
            exec(function () { /* empty */ }, function () { /* empty */ });
        };
        var constructor = promise.constructor = {};
        constructor[SPECIES$3] = FakePromise;
        SUBCLASSING = promise.then(function () { /* empty */ }) instanceof FakePromise;
        if (!SUBCLASSING) return true;
        // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
        return !GLOBAL_CORE_JS_PROMISE && engineIsBrowser && !NATIVE_REJECTION_EVENT;
    });

    var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {
        PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
    });

    // helpers
    var isThenable = function (it) {
        var then;
        return isObject(it) && isCallable(then = it.then) ? then : false;
    };

    var notify$1 = function (state, isReject) {
        if (state.notified) return;
        state.notified = true;
        var chain = state.reactions;
        microtask(function () {
            var value = state.value;
            var ok = state.state == FULFILLED;
            var index = 0;
            // variable length - can't use forEach
            while (chain.length > index) {
                var reaction = chain[index++];
                var handler = ok ? reaction.ok : reaction.fail;
                var resolve = reaction.resolve;
                var reject = reaction.reject;
                var domain = reaction.domain;
                var result, then, exited;
                try {
                    if (handler) {
                        if (!ok) {
                            if (state.rejection === UNHANDLED) onHandleUnhandled(state);
                            state.rejection = HANDLED;
                        }
                        if (handler === true) result = value;
                        else {
                            if (domain) domain.enter();
                            result = handler(value); // can throw
                            if (domain) {
                                domain.exit();
                                exited = true;
                            }
                        }
                        if (result === reaction.promise) {
                            reject(TypeError$1('Promise-chain cycle'));
                        } else if (then = isThenable(result)) {
                            then.call(result, resolve, reject);
                        } else resolve(result);
                    } else reject(value);
                } catch (error) {
                    if (domain && !exited) domain.exit();
                    reject(error);
                }
            }
            state.reactions = [];
            state.notified = false;
            if (isReject && !state.rejection) onUnhandled(state);
        });
    };

    var dispatchEvent = function (name, promise, reason) {
        var event, handler;
        if (DISPATCH_EVENT) {
            event = document$3.createEvent('Event');
            event.promise = promise;
            event.reason = reason;
            event.initEvent(name, false, true);
            global_1.dispatchEvent(event);
        } else event = { promise: promise, reason: reason };
        if (!NATIVE_REJECTION_EVENT && (handler = global_1['on' + name])) handler(event);
        else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
    };

    var onUnhandled = function (state) {
        task$1.call(global_1, function () {
            var promise = state.facade;
            var value = state.value;
            var IS_UNHANDLED = isUnhandled(state);
            var result;
            if (IS_UNHANDLED) {
                result = perform(function () {
                    if (engineIsNode) {
                        process$3.emit('unhandledRejection', value, promise);
                    } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
                });
                // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
                state.rejection = engineIsNode || isUnhandled(state) ? UNHANDLED : HANDLED;
                if (result.error) throw result.value;
            }
        });
    };

    var isUnhandled = function (state) {
        return state.rejection !== HANDLED && !state.parent;
    };

    var onHandleUnhandled = function (state) {
        task$1.call(global_1, function () {
            var promise = state.facade;
            if (engineIsNode) {
                process$3.emit('rejectionHandled', promise);
            } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
        });
    };

    var bind = function (fn, state, unwrap) {
        return function (value) {
            fn(state, value, unwrap);
        };
    };

    var internalReject = function (state, value, unwrap) {
        if (state.done) return;
        state.done = true;
        if (unwrap) state = unwrap;
        state.value = value;
        state.state = REJECTED;
        notify$1(state, true);
    };

    var internalResolve = function (state, value, unwrap) {
        if (state.done) return;
        state.done = true;
        if (unwrap) state = unwrap;
        try {
            if (state.facade === value) throw TypeError$1("Promise can't be resolved itself");
            var then = isThenable(value);
            if (then) {
                microtask(function () {
                    var wrapper = { done: false };
                    try {
                        then.call(value,
                            bind(internalResolve, wrapper, state),
                            bind(internalReject, wrapper, state)
                        );
                    } catch (error) {
                        internalReject(wrapper, error, state);
                    }
                });
            } else {
                state.value = value;
                state.state = FULFILLED;
                notify$1(state, false);
            }
        } catch (error) {
            internalReject({ done: false }, error, state);
        }
    };

    // constructor polyfill
    if (FORCED) {
        // 25.4.3.1 Promise(executor)
        PromiseConstructor = function Promise(executor) {
            anInstance(this, PromiseConstructor, PROMISE);
            aCallable(executor);
            Internal.call(this);
            var state = getInternalState(this);
            try {
                executor(bind(internalResolve, state), bind(internalReject, state));
            } catch (error) {
                internalReject(state, error);
            }
        };
        PromiseConstructorPrototype = PromiseConstructor.prototype;
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        Internal = function Promise(executor) {
            setInternalState(this, {
                type: PROMISE,
                done: false,
                notified: false,
                parent: false,
                reactions: [],
                rejection: false,
                state: PENDING,
                value: undefined
            });
        };
        Internal.prototype = redefineAll(PromiseConstructorPrototype, {
            // `Promise.prototype.then` method
            // https://tc39.es/ecma262/#sec-promise.prototype.then
            then: function then(onFulfilled, onRejected) {
                var state = getInternalPromiseState(this);
                var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));
                reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
                reaction.fail = isCallable(onRejected) && onRejected;
                reaction.domain = engineIsNode ? process$3.domain : undefined;
                state.parent = true;
                state.reactions.push(reaction);
                if (state.state != PENDING) notify$1(state, false);
                return reaction.promise;
            },
            // `Promise.prototype.catch` method
            // https://tc39.es/ecma262/#sec-promise.prototype.catch
            'catch': function (onRejected) {
                return this.then(undefined, onRejected);
            }
        });
        OwnPromiseCapability = function () {
            var promise = new Internal();
            var state = getInternalState(promise);
            this.promise = promise;
            this.resolve = bind(internalResolve, state);
            this.reject = bind(internalReject, state);
        };
        newPromiseCapability.f = newPromiseCapability$1 = function (C) {
            return C === PromiseConstructor || C === PromiseWrapper
                ? new OwnPromiseCapability(C)
                : newGenericPromiseCapability(C);
        };

        if (!isPure && isCallable(nativePromiseConstructor) && NativePromisePrototype !== Object.prototype) {
            nativeThen = NativePromisePrototype.then;

            if (!SUBCLASSING) {
                // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs
                redefine(NativePromisePrototype, 'then', function then(onFulfilled, onRejected) {
                    var that = this;
                    return new PromiseConstructor(function (resolve, reject) {
                        nativeThen.call(that, resolve, reject);
                    }).then(onFulfilled, onRejected);
                    // https://github.com/zloirock/core-js/issues/640
                }, { unsafe: true });

                // makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`
                redefine(NativePromisePrototype, 'catch', PromiseConstructorPrototype['catch'], { unsafe: true });
            }

            // make `.constructor === Promise` work for native promise-based APIs
            try {
                delete NativePromisePrototype.constructor;
            } catch (error) { /* empty */ }

            // make `instanceof Promise` work for native promise-based APIs
            if (objectSetPrototypeOf) {
                objectSetPrototypeOf(NativePromisePrototype, PromiseConstructorPrototype);
            }
        }
    }

    _export({ global: true, wrap: true, forced: FORCED }, {
        Promise: PromiseConstructor
    });

    setToStringTag(PromiseConstructor, PROMISE, false, true);
    setSpecies(PROMISE);

    PromiseWrapper = getBuiltIn(PROMISE);

    // statics
    _export({ target: PROMISE, stat: true, forced: FORCED }, {
        // `Promise.reject` method
        // https://tc39.es/ecma262/#sec-promise.reject
        reject: function reject(r) {
            var capability = newPromiseCapability$1(this);
            capability.reject.call(undefined, r);
            return capability.promise;
        }
    });

    _export({ target: PROMISE, stat: true, forced: isPure || FORCED }, {
        // `Promise.resolve` method
        // https://tc39.es/ecma262/#sec-promise.resolve
        resolve: function resolve(x) {
            return promiseResolve(isPure && this === PromiseWrapper ? PromiseConstructor : this, x);
        }
    });

    _export({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
        // `Promise.all` method
        // https://tc39.es/ecma262/#sec-promise.all
        all: function all(iterable) {
            var C = this;
            var capability = newPromiseCapability$1(C);
            var resolve = capability.resolve;
            var reject = capability.reject;
            var result = perform(function () {
                var $promiseResolve = aCallable(C.resolve);
                var values = [];
                var counter = 0;
                var remaining = 1;
                iterate(iterable, function (promise) {
                    var index = counter++;
                    var alreadyCalled = false;
                    values.push(undefined);
                    remaining++;
                    $promiseResolve.call(C, promise).then(function (value) {
                        if (alreadyCalled) return;
                        alreadyCalled = true;
                        values[index] = value;
                        --remaining || resolve(values);
                    }, reject);
                });
                --remaining || resolve(values);
            });
            if (result.error) reject(result.value);
            return capability.promise;
        },
        // `Promise.race` method
        // https://tc39.es/ecma262/#sec-promise.race
        race: function race(iterable) {
            var C = this;
            var capability = newPromiseCapability$1(C);
            var reject = capability.reject;
            var result = perform(function () {
                var $promiseResolve = aCallable(C.resolve);
                iterate(iterable, function (promise) {
                    $promiseResolve.call(C, promise).then(capability.resolve, reject);
                });
            });
            if (result.error) reject(result.value);
            return capability.promise;
        }
    });

    var toString_1 = function (argument) {
        if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
        return String(argument);
    };

    // `Object.defineProperties` method
    // https://tc39.es/ecma262/#sec-object.defineproperties
    // eslint-disable-next-line es/no-object-defineproperties -- safe
    var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
        anObject(O);
        var keys = objectKeys(Properties);
        var length = keys.length;
        var index = 0;
        var key;
        while (length > index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);
        return O;
    };

    /* global ActiveXObject -- old IE, WSH */








    var GT = '>';
    var LT = '<';
    var PROTOTYPE = 'prototype';
    var SCRIPT = 'script';
    var IE_PROTO = sharedKey('IE_PROTO');

    var EmptyConstructor = function () { /* empty */ };

    var scriptTag = function (content) {
        return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
    };

    // Create object with fake `null` prototype: use ActiveX Object with cleared prototype
    var NullProtoObjectViaActiveX = function (activeXDocument) {
        activeXDocument.write(scriptTag(''));
        activeXDocument.close();
        var temp = activeXDocument.parentWindow.Object;
        activeXDocument = null; // avoid memory leak
        return temp;
    };

    // Create object with fake `null` prototype: use iframe Object with cleared prototype
    var NullProtoObjectViaIFrame = function () {
        // Thrash, waste and sodomy: IE GC bug
        var iframe = documentCreateElement('iframe');
        var JS = 'java' + SCRIPT + ':';
        var iframeDocument;
        iframe.style.display = 'none';
        html.appendChild(iframe);
        // https://github.com/zloirock/core-js/issues/475
        iframe.src = String(JS);
        iframeDocument = iframe.contentWindow.document;
        iframeDocument.open();
        iframeDocument.write(scriptTag('document.F=Object'));
        iframeDocument.close();
        return iframeDocument.F;
    };

    // Check for document.domain and active x support
    // No need to use active x approach when document.domain is not set
    // see https://github.com/es-shims/es5-shim/issues/150
    // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
    // avoid IE GC bug
    var activeXDocument;
    var NullProtoObject = function () {
        try {
            activeXDocument = new ActiveXObject('htmlfile');
        } catch (error) { /* ignore */ }
        NullProtoObject = typeof document != 'undefined'
            ? document.domain && activeXDocument
                ? NullProtoObjectViaActiveX(activeXDocument) // old IE
                : NullProtoObjectViaIFrame()
            : NullProtoObjectViaActiveX(activeXDocument); // WSH
        var length = enumBugKeys.length;
        while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
        return NullProtoObject();
    };

    hiddenKeys[IE_PROTO] = true;

    // `Object.create` method
    // https://tc39.es/ecma262/#sec-object.create
    var objectCreate = Object.create || function create(O, Properties) {
        var result;
        if (O !== null) {
            EmptyConstructor[PROTOTYPE] = anObject(O);
            result = new EmptyConstructor();
            EmptyConstructor[PROTOTYPE] = null;
            // add "__proto__" for Object.getPrototypeOf polyfill
            result[IE_PROTO] = O;
        } else result = NullProtoObject();
        return Properties === undefined ? result : objectDefineProperties(result, Properties);
    };

    /* eslint-disable es/no-object-getownpropertynames -- safe */

    var $getOwnPropertyNames = objectGetOwnPropertyNames.f;

    var toString$1 = {}.toString;

    var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
        ? Object.getOwnPropertyNames(window) : [];

    var getWindowNames = function (it) {
        try {
            return $getOwnPropertyNames(it);
        } catch (error) {
            return windowNames.slice();
        }
    };

    // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
    var f$6 = function getOwnPropertyNames(it) {
        return windowNames && toString$1.call(it) == '[object Window]'
            ? getWindowNames(it)
            : $getOwnPropertyNames(toIndexedObject(it));
    };

    var objectGetOwnPropertyNamesExternal = {
        f: f$6
    };

    var f$7 = wellKnownSymbol;

    var wellKnownSymbolWrapped = {
        f: f$7
    };

    var path = global_1;

    var defineProperty$2 = objectDefineProperty.f;

    var defineWellKnownSymbol = function (NAME) {
        var Symbol = path.Symbol || (path.Symbol = {});
        if (!hasOwnProperty_1(Symbol, NAME)) defineProperty$2(Symbol, NAME, {
            value: wellKnownSymbolWrapped.f(NAME)
        });
    };

    var $forEach$1 = arrayIteration.forEach;

    var HIDDEN = sharedKey('hidden');
    var SYMBOL = 'Symbol';
    var PROTOTYPE$1 = 'prototype';
    var TO_PRIMITIVE$1 = wellKnownSymbol('toPrimitive');
    var setInternalState$1 = internalState.set;
    var getInternalState$1 = internalState.getterFor(SYMBOL);
    var ObjectPrototype = Object[PROTOTYPE$1];
    var $Symbol = global_1.Symbol;
    var $stringify = getBuiltIn('JSON', 'stringify');
    var nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
    var nativeDefineProperty = objectDefineProperty.f;
    var nativeGetOwnPropertyNames = objectGetOwnPropertyNamesExternal.f;
    var nativePropertyIsEnumerable = objectPropertyIsEnumerable.f;
    var AllSymbols = shared('symbols');
    var ObjectPrototypeSymbols = shared('op-symbols');
    var StringToSymbolRegistry = shared('string-to-symbol-registry');
    var SymbolToStringRegistry = shared('symbol-to-string-registry');
    var WellKnownSymbolsStore$1 = shared('wks');
    var QObject = global_1.QObject;
    // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
    var USE_SETTER = !QObject || !QObject[PROTOTYPE$1] || !QObject[PROTOTYPE$1].findChild;

    // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
    var setSymbolDescriptor = descriptors && fails(function () {
        return objectCreate(nativeDefineProperty({}, 'a', {
            get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
        })).a != 7;
    }) ? function (O, P, Attributes) {
        var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
        if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
        nativeDefineProperty(O, P, Attributes);
        if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
            nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
        }
    } : nativeDefineProperty;

    var wrap = function (tag, description) {
        var symbol = AllSymbols[tag] = objectCreate($Symbol[PROTOTYPE$1]);
        setInternalState$1(symbol, {
            type: SYMBOL,
            tag: tag,
            description: description
        });
        if (!descriptors) symbol.description = description;
        return symbol;
    };

    var $defineProperty$1 = function defineProperty(O, P, Attributes) {
        if (O === ObjectPrototype) $defineProperty$1(ObjectPrototypeSymbols, P, Attributes);
        anObject(O);
        var key = toPropertyKey(P);
        anObject(Attributes);
        if (hasOwnProperty_1(AllSymbols, key)) {
            if (!Attributes.enumerable) {
                if (!hasOwnProperty_1(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
                O[HIDDEN][key] = true;
            } else {
                if (hasOwnProperty_1(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
                Attributes = objectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
            } return setSymbolDescriptor(O, key, Attributes);
        } return nativeDefineProperty(O, key, Attributes);
    };

    var $defineProperties = function defineProperties(O, Properties) {
        anObject(O);
        var properties = toIndexedObject(Properties);
        var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
        $forEach$1(keys, function (key) {
            if (!descriptors || $propertyIsEnumerable$1.call(properties, key)) $defineProperty$1(O, key, properties[key]);
        });
        return O;
    };

    var $create = function create(O, Properties) {
        return Properties === undefined ? objectCreate(O) : $defineProperties(objectCreate(O), Properties);
    };

    var $propertyIsEnumerable$1 = function propertyIsEnumerable(V) {
        var P = toPropertyKey(V);
        var enumerable = nativePropertyIsEnumerable.call(this, P);
        if (this === ObjectPrototype && hasOwnProperty_1(AllSymbols, P) && !hasOwnProperty_1(ObjectPrototypeSymbols, P)) return false;
        return enumerable || !hasOwnProperty_1(this, P) || !hasOwnProperty_1(AllSymbols, P) || hasOwnProperty_1(this, HIDDEN) && this[HIDDEN][P]
            ? enumerable : true;
    };

    var $getOwnPropertyDescriptor$1 = function getOwnPropertyDescriptor(O, P) {
        var it = toIndexedObject(O);
        var key = toPropertyKey(P);
        if (it === ObjectPrototype && hasOwnProperty_1(AllSymbols, key) && !hasOwnProperty_1(ObjectPrototypeSymbols, key)) return;
        var descriptor = nativeGetOwnPropertyDescriptor(it, key);
        if (descriptor && hasOwnProperty_1(AllSymbols, key) && !(hasOwnProperty_1(it, HIDDEN) && it[HIDDEN][key])) {
            descriptor.enumerable = true;
        }
        return descriptor;
    };

    var $getOwnPropertyNames$1 = function getOwnPropertyNames(O) {
        var names = nativeGetOwnPropertyNames(toIndexedObject(O));
        var result = [];
        $forEach$1(names, function (key) {
            if (!hasOwnProperty_1(AllSymbols, key) && !hasOwnProperty_1(hiddenKeys, key)) result.push(key);
        });
        return result;
    };

    var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
        var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
        var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
        var result = [];
        $forEach$1(names, function (key) {
            if (hasOwnProperty_1(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwnProperty_1(ObjectPrototype, key))) {
                result.push(AllSymbols[key]);
            }
        });
        return result;
    };

    // `Symbol` constructor
    // https://tc39.es/ecma262/#sec-symbol-constructor
    if (!nativeSymbol) {
        $Symbol = function Symbol() {
            if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
            var description = !arguments.length || arguments[0] === undefined ? undefined : toString_1(arguments[0]);
            var tag = uid(description);
            var setter = function (value) {
                if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
                if (hasOwnProperty_1(this, HIDDEN) && hasOwnProperty_1(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
                setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
            };
            if (descriptors && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
            return wrap(tag, description);
        };

        redefine($Symbol[PROTOTYPE$1], 'toString', function toString() {
            return getInternalState$1(this).tag;
        });

        redefine($Symbol, 'withoutSetter', function (description) {
            return wrap(uid(description), description);
        });

        objectPropertyIsEnumerable.f = $propertyIsEnumerable$1;
        objectDefineProperty.f = $defineProperty$1;
        objectGetOwnPropertyDescriptor.f = $getOwnPropertyDescriptor$1;
        objectGetOwnPropertyNames.f = objectGetOwnPropertyNamesExternal.f = $getOwnPropertyNames$1;
        objectGetOwnPropertySymbols.f = $getOwnPropertySymbols;

        wellKnownSymbolWrapped.f = function (name) {
            return wrap(wellKnownSymbol(name), name);
        };

        if (descriptors) {
            // https://github.com/tc39/proposal-Symbol-description
            nativeDefineProperty($Symbol[PROTOTYPE$1], 'description', {
                configurable: true,
                get: function description() {
                    return getInternalState$1(this).description;
                }
            });
            {
                redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable$1, { unsafe: true });
            }
        }
    }

    _export({ global: true, wrap: true, forced: !nativeSymbol, sham: !nativeSymbol }, {
        Symbol: $Symbol
    });

    $forEach$1(objectKeys(WellKnownSymbolsStore$1), function (name) {
        defineWellKnownSymbol(name);
    });

    _export({ target: SYMBOL, stat: true, forced: !nativeSymbol }, {
        // `Symbol.for` method
        // https://tc39.es/ecma262/#sec-symbol.for
        'for': function (key) {
            var string = toString_1(key);
            if (hasOwnProperty_1(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
            var symbol = $Symbol(string);
            StringToSymbolRegistry[string] = symbol;
            SymbolToStringRegistry[symbol] = string;
            return symbol;
        },
        // `Symbol.keyFor` method
        // https://tc39.es/ecma262/#sec-symbol.keyfor
        keyFor: function keyFor(sym) {
            if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
            if (hasOwnProperty_1(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
        },
        useSetter: function () { USE_SETTER = true; },
        useSimple: function () { USE_SETTER = false; }
    });

    _export({ target: 'Object', stat: true, forced: !nativeSymbol, sham: !descriptors }, {
        // `Object.create` method
        // https://tc39.es/ecma262/#sec-object.create
        create: $create,
        // `Object.defineProperty` method
        // https://tc39.es/ecma262/#sec-object.defineproperty
        defineProperty: $defineProperty$1,
        // `Object.defineProperties` method
        // https://tc39.es/ecma262/#sec-object.defineproperties
        defineProperties: $defineProperties,
        // `Object.getOwnPropertyDescriptor` method
        // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
        getOwnPropertyDescriptor: $getOwnPropertyDescriptor$1
    });

    _export({ target: 'Object', stat: true, forced: !nativeSymbol }, {
        // `Object.getOwnPropertyNames` method
        // https://tc39.es/ecma262/#sec-object.getownpropertynames
        getOwnPropertyNames: $getOwnPropertyNames$1,
        // `Object.getOwnPropertySymbols` method
        // https://tc39.es/ecma262/#sec-object.getownpropertysymbols
        getOwnPropertySymbols: $getOwnPropertySymbols
    });

    // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
    // https://bugs.chromium.org/p/v8/issues/detail?id=3443
    _export({ target: 'Object', stat: true, forced: fails(function () { objectGetOwnPropertySymbols.f(1); }) }, {
        getOwnPropertySymbols: function getOwnPropertySymbols(it) {
            return objectGetOwnPropertySymbols.f(toObject(it));
        }
    });

    // `JSON.stringify` method behavior with symbols
    // https://tc39.es/ecma262/#sec-json.stringify
    if ($stringify) {
        var FORCED_JSON_STRINGIFY = !nativeSymbol || fails(function () {
            var symbol = $Symbol();
            // MS Edge converts symbol values to JSON as {}
            return $stringify([symbol]) != '[null]'
                // WebKit converts symbol values to JSON as null
                || $stringify({ a: symbol }) != '{}'
                // V8 throws on boxed symbols
                || $stringify(Object(symbol)) != '{}';
        });

        _export({ target: 'JSON', stat: true, forced: FORCED_JSON_STRINGIFY }, {
            // eslint-disable-next-line no-unused-vars -- required for `.length`
            stringify: function stringify(it, replacer, space) {
                var args = [it];
                var index = 1;
                var $replacer;
                while (arguments.length > index) args.push(arguments[index++]);
                $replacer = replacer;
                if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
                if (!isArray(replacer)) replacer = function (key, value) {
                    if (isCallable($replacer)) value = $replacer.call(this, key, value);
                    if (!isSymbol(value)) return value;
                };
                args[1] = replacer;
                return $stringify.apply(null, args);
            }
        });
    }

    // `Symbol.prototype[@@toPrimitive]` method
    // https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
    if (!$Symbol[PROTOTYPE$1][TO_PRIMITIVE$1]) {
        var valueOf = $Symbol[PROTOTYPE$1].valueOf;
        redefine($Symbol[PROTOTYPE$1], TO_PRIMITIVE$1, function () {
            return valueOf.apply(this, arguments);
        });
    }
    // `Symbol.prototype[@@toStringTag]` property
    // https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
    setToStringTag($Symbol, SYMBOL);

    hiddenKeys[HIDDEN] = true;

    var defineProperty$3 = objectDefineProperty.f;


    var NativeSymbol = global_1.Symbol;

    if (descriptors && isCallable(NativeSymbol) && (!('description' in NativeSymbol.prototype) ||
        // Safari 12 bug
        NativeSymbol().description !== undefined
    )) {
        var EmptyStringDescriptionStore = {};
        // wrap Symbol constructor for correct work with undefined description
        var SymbolWrapper = function Symbol() {
            var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
            var result = this instanceof SymbolWrapper
                ? new NativeSymbol(description)
                // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
                : description === undefined ? NativeSymbol() : NativeSymbol(description);
            if (description === '') EmptyStringDescriptionStore[result] = true;
            return result;
        };
        copyConstructorProperties(SymbolWrapper, NativeSymbol);
        var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
        symbolPrototype.constructor = SymbolWrapper;

        var symbolToString = symbolPrototype.toString;
        var nativeSymbol$1 = String(NativeSymbol('test')) == 'Symbol(test)';
        var regexp = /^Symbol\((.*)\)[^)]+$/;
        defineProperty$3(symbolPrototype, 'description', {
            configurable: true,
            get: function description() {
                var symbol = isObject(this) ? this.valueOf() : this;
                var string = symbolToString.call(symbol);
                if (hasOwnProperty_1(EmptyStringDescriptionStore, symbol)) return '';
                var desc = nativeSymbol$1 ? string.slice(7, -1) : string.replace(regexp, '$1');
                return desc === '' ? undefined : desc;
            }
        });

        _export({ global: true, forced: true }, {
            Symbol: SymbolWrapper
        });
    }

    var UNSCOPABLES = wellKnownSymbol('unscopables');
    var ArrayPrototype$1 = Array.prototype;

    // Array.prototype[@@unscopables]
    // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
    if (ArrayPrototype$1[UNSCOPABLES] == undefined) {
        objectDefineProperty.f(ArrayPrototype$1, UNSCOPABLES, {
            configurable: true,
            value: objectCreate(null)
        });
    }

    // add a key to Array.prototype[@@unscopables]
    var addToUnscopables = function (key) {
        ArrayPrototype$1[UNSCOPABLES][key] = true;
    };

    var correctPrototypeGetter = !fails(function () {
        function F() { /* empty */ }
        F.prototype.constructor = null;
        // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
        return Object.getPrototypeOf(new F()) !== F.prototype;
    });

    var IE_PROTO$1 = sharedKey('IE_PROTO');
    var ObjectPrototype$1 = Object.prototype;

    // `Object.getPrototypeOf` method
    // https://tc39.es/ecma262/#sec-object.getprototypeof
    // eslint-disable-next-line es/no-object-getprototypeof -- safe
    var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {
        var object = toObject(O);
        if (hasOwnProperty_1(object, IE_PROTO$1)) return object[IE_PROTO$1];
        var constructor = object.constructor;
        if (isCallable(constructor) && object instanceof constructor) {
            return constructor.prototype;
        } return object instanceof Object ? ObjectPrototype$1 : null;
    };

    var ITERATOR$3 = wellKnownSymbol('iterator');
    var BUGGY_SAFARI_ITERATORS = false;

    // `%IteratorPrototype%` object
    // https://tc39.es/ecma262/#sec-%iteratorprototype%-object
    var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

    /* eslint-disable es/no-array-prototype-keys -- safe */
    if ([].keys) {
        arrayIterator = [].keys();
        // Safari 8 has buggy iterators w/o `next`
        if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
        else {
            PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
            if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
        }
    }

    var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {
        var test = {};
        // FF44- legacy iterators case
        return IteratorPrototype[ITERATOR$3].call(test) !== test;
    });

    if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};

    // `%IteratorPrototype%[@@iterator]()` method
    // https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
    if (!isCallable(IteratorPrototype[ITERATOR$3])) {
        redefine(IteratorPrototype, ITERATOR$3, function () {
            return this;
        });
    }

    var iteratorsCore = {
        IteratorPrototype: IteratorPrototype,
        BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
    };

    var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;





    var returnThis = function () { return this; };

    var createIteratorConstructor = function (IteratorConstructor, NAME, next) {
        var TO_STRING_TAG = NAME + ' Iterator';
        IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, { next: createPropertyDescriptor(1, next) });
        setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
        iterators[TO_STRING_TAG] = returnThis;
        return IteratorConstructor;
    };

    var PROPER_FUNCTION_NAME = functionName.PROPER;
    var CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;
    var IteratorPrototype$2 = iteratorsCore.IteratorPrototype;
    var BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;
    var ITERATOR$4 = wellKnownSymbol('iterator');
    var KEYS = 'keys';
    var VALUES = 'values';
    var ENTRIES = 'entries';

    var returnThis$1 = function () { return this; };

    var defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
        createIteratorConstructor(IteratorConstructor, NAME, next);

        var getIterationMethod = function (KIND) {
            if (KIND === DEFAULT && defaultIterator) return defaultIterator;
            if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];
            switch (KIND) {
                case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
                case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
                case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
            } return function () { return new IteratorConstructor(this); };
        };

        var TO_STRING_TAG = NAME + ' Iterator';
        var INCORRECT_VALUES_NAME = false;
        var IterablePrototype = Iterable.prototype;
        var nativeIterator = IterablePrototype[ITERATOR$4]
            || IterablePrototype['@@iterator']
            || DEFAULT && IterablePrototype[DEFAULT];
        var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);
        var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
        var CurrentIteratorPrototype, methods, KEY;

        // fix native
        if (anyNativeIterator) {
            CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));
            if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
                if (objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$2) {
                    if (objectSetPrototypeOf) {
                        objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$2);
                    } else if (!isCallable(CurrentIteratorPrototype[ITERATOR$4])) {
                        redefine(CurrentIteratorPrototype, ITERATOR$4, returnThis$1);
                    }
                }
                // Set @@toStringTag to native iterators
                setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
            }
        }

        // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
        if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
            if (CONFIGURABLE_FUNCTION_NAME) {
                createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
            } else {
                INCORRECT_VALUES_NAME = true;
                defaultIterator = function values() { return nativeIterator.call(this); };
            }
        }

        // export additional methods
        if (DEFAULT) {
            methods = {
                values: getIterationMethod(VALUES),
                keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
                entries: getIterationMethod(ENTRIES)
            };
            if (FORCED) for (KEY in methods) {
                if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                    redefine(IterablePrototype, KEY, methods[KEY]);
                }
            } else _export({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME }, methods);
        }

        // define iterator
        if (IterablePrototype[ITERATOR$4] !== defaultIterator) {
            redefine(IterablePrototype, ITERATOR$4, defaultIterator, { name: DEFAULT });
        }
        iterators[NAME] = defaultIterator;

        return methods;
    };

    var ARRAY_ITERATOR = 'Array Iterator';
    var setInternalState$2 = internalState.set;
    var getInternalState$2 = internalState.getterFor(ARRAY_ITERATOR);

    // `Array.prototype.entries` method
    // https://tc39.es/ecma262/#sec-array.prototype.entries
    // `Array.prototype.keys` method
    // https://tc39.es/ecma262/#sec-array.prototype.keys
    // `Array.prototype.values` method
    // https://tc39.es/ecma262/#sec-array.prototype.values
    // `Array.prototype[@@iterator]` method
    // https://tc39.es/ecma262/#sec-array.prototype-@@iterator
    // `CreateArrayIterator` internal method
    // https://tc39.es/ecma262/#sec-createarrayiterator
    var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
        setInternalState$2(this, {
            type: ARRAY_ITERATOR,
            target: toIndexedObject(iterated), // target
            index: 0,                          // next index
            kind: kind                         // kind
        });
        // `%ArrayIteratorPrototype%.next` method
        // https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
    }, function () {
        var state = getInternalState$2(this);
        var target = state.target;
        var kind = state.kind;
        var index = state.index++;
        if (!target || index >= target.length) {
            state.target = undefined;
            return { value: undefined, done: true };
        }
        if (kind == 'keys') return { value: index, done: false };
        if (kind == 'values') return { value: target[index], done: false };
        return { value: [index, target[index]], done: false };
    }, 'values');

    // argumentsList[@@iterator] is %ArrayProto_values%
    // https://tc39.es/ecma262/#sec-createunmappedargumentsobject
    // https://tc39.es/ecma262/#sec-createmappedargumentsobject
    iterators.Arguments = iterators.Array;

    // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
    addToUnscopables('keys');
    addToUnscopables('values');
    addToUnscopables('entries');

    var createMethod$2 = function (CONVERT_TO_STRING) {
        return function ($this, pos) {
            var S = toString_1(requireObjectCoercible($this));
            var position = toIntegerOrInfinity(pos);
            var size = S.length;
            var first, second;
            if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
            first = S.charCodeAt(position);
            return first < 0xD800 || first > 0xDBFF || position + 1 === size
                || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
                ? CONVERT_TO_STRING ? S.charAt(position) : first
                : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
        };
    };

    var stringMultibyte = {
        // `String.prototype.codePointAt` method
        // https://tc39.es/ecma262/#sec-string.prototype.codepointat
        codeAt: createMethod$2(false),
        // `String.prototype.at` method
        // https://github.com/mathiasbynens/String.prototype.at
        charAt: createMethod$2(true)
    };

    var charAt = stringMultibyte.charAt;




    var STRING_ITERATOR = 'String Iterator';
    var setInternalState$3 = internalState.set;
    var getInternalState$3 = internalState.getterFor(STRING_ITERATOR);

    // `String.prototype[@@iterator]` method
    // https://tc39.es/ecma262/#sec-string.prototype-@@iterator
    defineIterator(String, 'String', function (iterated) {
        setInternalState$3(this, {
            type: STRING_ITERATOR,
            string: toString_1(iterated),
            index: 0
        });
        // `%StringIteratorPrototype%.next` method
        // https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
    }, function next() {
        var state = getInternalState$3(this);
        var string = state.string;
        var index = state.index;
        var point;
        if (index >= string.length) return { value: undefined, done: true };
        point = charAt(string, index);
        state.index += point.length;
        return { value: point, done: false };
    });

    var ITERATOR$5 = wellKnownSymbol('iterator');
    var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');
    var ArrayValues = es_array_iterator.values;

    var handlePrototype$1 = function (CollectionPrototype, COLLECTION_NAME) {
        if (CollectionPrototype) {
            // some Chrome versions have non-configurable methods on DOMTokenList
            if (CollectionPrototype[ITERATOR$5] !== ArrayValues) try {
                createNonEnumerableProperty(CollectionPrototype, ITERATOR$5, ArrayValues);
            } catch (error) {
                CollectionPrototype[ITERATOR$5] = ArrayValues;
            }
            if (!CollectionPrototype[TO_STRING_TAG$3]) {
                createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG$3, COLLECTION_NAME);
            }
            if (domIterables[COLLECTION_NAME]) for (var METHOD_NAME in es_array_iterator) {
                // some Chrome versions have non-configurable methods on DOMTokenList
                if (CollectionPrototype[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) try {
                    createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, es_array_iterator[METHOD_NAME]);
                } catch (error) {
                    CollectionPrototype[METHOD_NAME] = es_array_iterator[METHOD_NAME];
                }
            }
        }
    };

    for (var COLLECTION_NAME$1 in domIterables) {
        handlePrototype$1(global_1[COLLECTION_NAME$1] && global_1[COLLECTION_NAME$1].prototype, COLLECTION_NAME$1);
    }

    handlePrototype$1(domTokenListPrototype, 'DOMTokenList');

    // `RegExp.prototype.flags` getter implementation
    // https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
    var regexpFlags = function () {
        var that = anObject(this);
        var result = '';
        if (that.global) result += 'g';
        if (that.ignoreCase) result += 'i';
        if (that.multiline) result += 'm';
        if (that.dotAll) result += 's';
        if (that.unicode) result += 'u';
        if (that.sticky) result += 'y';
        return result;
    };

    // babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
    var $RegExp = global_1.RegExp;

    var UNSUPPORTED_Y = fails(function () {
        var re = $RegExp('a', 'y');
        re.lastIndex = 2;
        return re.exec('abcd') != null;
    });

    var BROKEN_CARET = fails(function () {
        // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
        var re = $RegExp('^r', 'gy');
        re.lastIndex = 2;
        return re.exec('str') != null;
    });

    var regexpStickyHelpers = {
        UNSUPPORTED_Y: UNSUPPORTED_Y,
        BROKEN_CARET: BROKEN_CARET
    };

    // babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError
    var $RegExp$1 = global_1.RegExp;

    var regexpUnsupportedDotAll = fails(function () {
        var re = $RegExp$1('.', 's');
        return !(re.dotAll && re.exec('\n') && re.flags === 's');
    });

    // babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError
    var $RegExp$2 = global_1.RegExp;

    var regexpUnsupportedNcg = fails(function () {
        var re = $RegExp$2('(?<a>b)', 'g');
        return re.exec('b').groups.a !== 'b' ||
            'b'.replace(re, '$<a>c') !== 'bc';
    });

    /* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */
    /* eslint-disable regexp/no-useless-quantifier -- testing */





    var getInternalState$4 = internalState.get;



    var nativeExec = RegExp.prototype.exec;
    var nativeReplace = shared('native-string-replace', String.prototype.replace);

    var patchedExec = nativeExec;

    var UPDATES_LAST_INDEX_WRONG = (function () {
        var re1 = /a/;
        var re2 = /b*/g;
        nativeExec.call(re1, 'a');
        nativeExec.call(re2, 'a');
        return re1.lastIndex !== 0 || re2.lastIndex !== 0;
    })();

    var UNSUPPORTED_Y$1 = regexpStickyHelpers.UNSUPPORTED_Y || regexpStickyHelpers.BROKEN_CARET;

    // nonparticipating capturing group, copied from es5-shim's String#split patch.
    var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

    var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1 || regexpUnsupportedDotAll || regexpUnsupportedNcg;

    if (PATCH) {
        // eslint-disable-next-line max-statements -- TODO
        patchedExec = function exec(string) {
            var re = this;
            var state = getInternalState$4(re);
            var str = toString_1(string);
            var raw = state.raw;
            var result, reCopy, lastIndex, match, i, object, group;

            if (raw) {
                raw.lastIndex = re.lastIndex;
                result = patchedExec.call(raw, str);
                re.lastIndex = raw.lastIndex;
                return result;
            }

            var groups = state.groups;
            var sticky = UNSUPPORTED_Y$1 && re.sticky;
            var flags = regexpFlags.call(re);
            var source = re.source;
            var charsAdded = 0;
            var strCopy = str;

            if (sticky) {
                flags = flags.replace('y', '');
                if (flags.indexOf('g') === -1) {
                    flags += 'g';
                }

                strCopy = str.slice(re.lastIndex);
                // Support anchored sticky behavior.
                if (re.lastIndex > 0 && (!re.multiline || re.multiline && str.charAt(re.lastIndex - 1) !== '\n')) {
                    source = '(?: ' + source + ')';
                    strCopy = ' ' + strCopy;
                    charsAdded++;
                }
                // ^(? + rx + ) is needed, in combination with some str slicing, to
                // simulate the 'y' flag.
                reCopy = new RegExp('^(?:' + source + ')', flags);
            }

            if (NPCG_INCLUDED) {
                reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
            }
            if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

            match = nativeExec.call(sticky ? reCopy : re, strCopy);

            if (sticky) {
                if (match) {
                    match.input = match.input.slice(charsAdded);
                    match[0] = match[0].slice(charsAdded);
                    match.index = re.lastIndex;
                    re.lastIndex += match[0].length;
                } else re.lastIndex = 0;
            } else if (UPDATES_LAST_INDEX_WRONG && match) {
                re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
            }
            if (NPCG_INCLUDED && match && match.length > 1) {
                // Fix browsers whose `exec` methods don't consistently return `undefined`
                // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
                nativeReplace.call(match[0], reCopy, function () {
                    for (i = 1; i < arguments.length - 2; i++) {
                        if (arguments[i] === undefined) match[i] = undefined;
                    }
                });
            }

            if (match && groups) {
                match.groups = object = objectCreate(null);
                for (i = 0; i < groups.length; i++) {
                    group = groups[i];
                    object[group[0]] = match[group[1]];
                }
            }

            return match;
        };
    }

    var regexpExec = patchedExec;

    // `RegExp.prototype.exec` method
    // https://tc39.es/ecma262/#sec-regexp.prototype.exec
    _export({ target: 'RegExp', proto: true, forced: /./.exec !== regexpExec }, {
        exec: regexpExec
    });

    // TODO: Remove from `core-js@4` since it's moved to entry points







    var SPECIES$4 = wellKnownSymbol('species');
    var RegExpPrototype = RegExp.prototype;

    var fixRegexpWellKnownSymbolLogic = function (KEY, exec, FORCED, SHAM) {
        var SYMBOL = wellKnownSymbol(KEY);

        var DELEGATES_TO_SYMBOL = !fails(function () {
            // String methods call symbol-named RegEp methods
            var O = {};
            O[SYMBOL] = function () { return 7; };
            return ''[KEY](O) != 7;
        });

        var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
            // Symbol-named RegExp methods call .exec
            var execCalled = false;
            var re = /a/;

            if (KEY === 'split') {
                // We can't use real regex here since it causes deoptimization
                // and serious performance degradation in V8
                // https://github.com/zloirock/core-js/issues/306
                re = {};
                // RegExp[@@split] doesn't call the regex's exec method, but first creates
                // a new one. We need to return the patched regex when creating the new one.
                re.constructor = {};
                re.constructor[SPECIES$4] = function () { return re; };
                re.flags = '';
                re[SYMBOL] = /./[SYMBOL];
            }

            re.exec = function () { execCalled = true; return null; };

            re[SYMBOL]('');
            return !execCalled;
        });

        if (
            !DELEGATES_TO_SYMBOL ||
            !DELEGATES_TO_EXEC ||
            FORCED
        ) {
            var nativeRegExpMethod = /./[SYMBOL];
            var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
                var $exec = regexp.exec;
                if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
                    if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                        // The native String method already delegates to @@method (this
                        // polyfilled function), leasing to infinite recursion.
                        // We avoid it by directly calling the native @@method method.
                        return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
                    }
                    return { done: true, value: nativeMethod.call(str, regexp, arg2) };
                }
                return { done: false };
            });

            redefine(String.prototype, KEY, methods[0]);
            redefine(RegExpPrototype, SYMBOL, methods[1]);
        }

        if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], 'sham', true);
    };

    var MATCH = wellKnownSymbol('match');

    // `IsRegExp` abstract operation
    // https://tc39.es/ecma262/#sec-isregexp
    var isRegexp = function (it) {
        var isRegExp;
        return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');
    };

    var charAt$1 = stringMultibyte.charAt;

    // `AdvanceStringIndex` abstract operation
    // https://tc39.es/ecma262/#sec-advancestringindex
    var advanceStringIndex = function (S, index, unicode) {
        return index + (unicode ? charAt$1(S, index).length : 1);
    };

    // `RegExpExec` abstract operation
    // https://tc39.es/ecma262/#sec-regexpexec
    var regexpExecAbstract = function (R, S) {
        var exec = R.exec;
        if (isCallable(exec)) {
            var result = exec.call(R, S);
            if (result !== null) anObject(result);
            return result;
        }
        if (classofRaw(R) === 'RegExp') return regexpExec.call(R, S);
        throw TypeError('RegExp#exec called on incompatible receiver');
    };

    var UNSUPPORTED_Y$2 = regexpStickyHelpers.UNSUPPORTED_Y;
    var arrayPush = [].push;
    var min$2 = Math.min;
    var MAX_UINT32 = 0xFFFFFFFF;

    // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
    // Weex JS has frozen built-in prototypes, so use try / catch wrapper
    var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
        // eslint-disable-next-line regexp/no-empty-group -- required for testing
        var re = /(?:)/;
        var originalExec = re.exec;
        re.exec = function () { return originalExec.apply(this, arguments); };
        var result = 'ab'.split(re);
        return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
    });

    // @@split logic
    fixRegexpWellKnownSymbolLogic('split', function (SPLIT, nativeSplit, maybeCallNative) {
        var internalSplit;
        if (
            'abbc'.split(/(b)*/)[1] == 'c' ||
            // eslint-disable-next-line regexp/no-empty-group -- required for testing
            'test'.split(/(?:)/, -1).length != 4 ||
            'ab'.split(/(?:ab)*/).length != 2 ||
            '.'.split(/(.?)(.?)/).length != 4 ||
            // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
            '.'.split(/()()/).length > 1 ||
            ''.split(/.?/).length
        ) {
            // based on es5-shim implementation, need to rework it
            internalSplit = function (separator, limit) {
                var string = toString_1(requireObjectCoercible(this));
                var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
                if (lim === 0) return [];
                if (separator === undefined) return [string];
                // If `separator` is not a regex, use native split
                if (!isRegexp(separator)) {
                    return nativeSplit.call(string, separator, lim);
                }
                var output = [];
                var flags = (separator.ignoreCase ? 'i' : '') +
                    (separator.multiline ? 'm' : '') +
                    (separator.unicode ? 'u' : '') +
                    (separator.sticky ? 'y' : '');
                var lastLastIndex = 0;
                // Make `global` and avoid `lastIndex` issues by working with a copy
                var separatorCopy = new RegExp(separator.source, flags + 'g');
                var match, lastIndex, lastLength;
                while (match = regexpExec.call(separatorCopy, string)) {
                    lastIndex = separatorCopy.lastIndex;
                    if (lastIndex > lastLastIndex) {
                        output.push(string.slice(lastLastIndex, match.index));
                        if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
                        lastLength = match[0].length;
                        lastLastIndex = lastIndex;
                        if (output.length >= lim) break;
                    }
                    if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
                }
                if (lastLastIndex === string.length) {
                    if (lastLength || !separatorCopy.test('')) output.push('');
                } else output.push(string.slice(lastLastIndex));
                return output.length > lim ? output.slice(0, lim) : output;
            };
            // Chakra, V8
        } else if ('0'.split(undefined, 0).length) {
            internalSplit = function (separator, limit) {
                return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
            };
        } else internalSplit = nativeSplit;

        return [
            // `String.prototype.split` method
            // https://tc39.es/ecma262/#sec-string.prototype.split
            function split(separator, limit) {
                var O = requireObjectCoercible(this);
                var splitter = separator == undefined ? undefined : getMethod(separator, SPLIT);
                return splitter
                    ? splitter.call(separator, O, limit)
                    : internalSplit.call(toString_1(O), separator, limit);
            },
            // `RegExp.prototype[@@split]` method
            // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
            //
            // NOTE: This cannot be properly polyfilled in engines that don't support
            // the 'y' flag.
            function (string, limit) {
                var rx = anObject(this);
                var S = toString_1(string);
                var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);

                if (res.done) return res.value;

                var C = speciesConstructor(rx, RegExp);

                var unicodeMatching = rx.unicode;
                var flags = (rx.ignoreCase ? 'i' : '') +
                    (rx.multiline ? 'm' : '') +
                    (rx.unicode ? 'u' : '') +
                    (UNSUPPORTED_Y$2 ? 'g' : 'y');

                // ^(? + rx + ) is needed, in combination with some S slicing, to
                // simulate the 'y' flag.
                var splitter = new C(UNSUPPORTED_Y$2 ? '^(?:' + rx.source + ')' : rx, flags);
                var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
                if (lim === 0) return [];
                if (S.length === 0) return regexpExecAbstract(splitter, S) === null ? [S] : [];
                var p = 0;
                var q = 0;
                var A = [];
                while (q < S.length) {
                    splitter.lastIndex = UNSUPPORTED_Y$2 ? 0 : q;
                    var z = regexpExecAbstract(splitter, UNSUPPORTED_Y$2 ? S.slice(q) : S);
                    var e;
                    if (
                        z === null ||
                        (e = min$2(toLength(splitter.lastIndex + (UNSUPPORTED_Y$2 ? q : 0)), S.length)) === p
                    ) {
                        q = advanceStringIndex(S, q, unicodeMatching);
                    } else {
                        A.push(S.slice(p, q));
                        if (A.length === lim) return A;
                        for (var i = 1; i <= z.length - 1; i++) {
                            A.push(z[i]);
                            if (A.length === lim) return A;
                        }
                        q = p = e;
                    }
                }
                A.push(S.slice(p));
                return A;
            }
        ];
    }, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y$2);

    var $findIndex = arrayIteration.findIndex;


    var FIND_INDEX = 'findIndex';
    var SKIPS_HOLES = true;

    // Shouldn't skip holes
    if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () { SKIPS_HOLES = false; });

    // `Array.prototype.findIndex` method
    // https://tc39.es/ecma262/#sec-array.prototype.findindex
    _export({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
        findIndex: function findIndex(callbackfn /* , that = undefined */) {
            return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        }
    });

    // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
    addToUnscopables(FIND_INDEX);

    var createProperty = function (object, key, value) {
        var propertyKey = toPropertyKey(key);
        if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));
        else object[propertyKey] = value;
    };

    var SPECIES$5 = wellKnownSymbol('species');

    var arrayMethodHasSpeciesSupport = function (METHOD_NAME) {
        // We can't use this feature detection in V8 since it causes
        // deoptimization and serious performance degradation
        // https://github.com/zloirock/core-js/issues/677
        return engineV8Version >= 51 || !fails(function () {
            var array = [];
            var constructor = array.constructor = {};
            constructor[SPECIES$5] = function () {
                return { foo: 1 };
            };
            return array[METHOD_NAME](Boolean).foo !== 1;
        });
    };

    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');

    var max$1 = Math.max;
    var min$3 = Math.min;
    var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
    var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

    // `Array.prototype.splice` method
    // https://tc39.es/ecma262/#sec-array.prototype.splice
    // with adding support of @@species
    _export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
        splice: function splice(start, deleteCount /* , ...items */) {
            var O = toObject(this);
            var len = lengthOfArrayLike(O);
            var actualStart = toAbsoluteIndex(start, len);
            var argumentsLength = arguments.length;
            var insertCount, actualDeleteCount, A, k, from, to;
            if (argumentsLength === 0) {
                insertCount = actualDeleteCount = 0;
            } else if (argumentsLength === 1) {
                insertCount = 0;
                actualDeleteCount = len - actualStart;
            } else {
                insertCount = argumentsLength - 2;
                actualDeleteCount = min$3(max$1(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
            }
            if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
                throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
            }
            A = arraySpeciesCreate(O, actualDeleteCount);
            for (k = 0; k < actualDeleteCount; k++) {
                from = actualStart + k;
                if (from in O) createProperty(A, k, O[from]);
            }
            A.length = actualDeleteCount;
            if (insertCount < actualDeleteCount) {
                for (k = actualStart; k < len - actualDeleteCount; k++) {
                    from = k + actualDeleteCount;
                    to = k + insertCount;
                    if (from in O) O[to] = O[from];
                    else delete O[to];
                }
                for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
            } else if (insertCount > actualDeleteCount) {
                for (k = len - actualDeleteCount; k > actualStart; k--) {
                    from = k + actualDeleteCount - 1;
                    to = k + insertCount - 1;
                    if (from in O) O[to] = O[from];
                    else delete O[to];
                }
            }
            for (k = 0; k < insertCount; k++) {
                O[k + actualStart] = arguments[k + 2];
            }
            O.length = len - actualDeleteCount + insertCount;
            return A;
        }
    });

    var timerDebounce = undefined;
    function debounce(duration, callback) {
        clearTimeout(timerDebounce);
        timerDebounce = setTimeout(function () {
            callback();
        }, duration);
        return timerDebounce;
    }
    function transitionAsPromise(triggeringFunc, el) {
        var _this = this;

        return new Promise(function (resolve) {
            var _this2 = this;

            _newArrowCheck(this, _this);

            var _handleTransitionEnd = function handleTransitionEnd() {
                _newArrowCheck(this, _this2);

                el.removeEventListener('transitionend', _handleTransitionEnd);
                resolve();
            }.bind(this);

            el.addEventListener('transitionend', _handleTransitionEnd);
            var classesBefore = el.getAttribute('class');
            var stylesBefore = el.getAttribute('style');
            triggeringFunc();

            if (classesBefore === el.getAttribute('class') && stylesBefore === el.getAttribute('style')) {
                _handleTransitionEnd();
            }

            if (parseFloat(getComputedStyle(el)['transitionDuration']) === 0) {
                _handleTransitionEnd();
            }
        }.bind(this));
    }
    function loadImage(_ref) {
        var _this3 = this;

        var src = _ref.src,
            srcset = _ref.srcset,
            sizes = _ref.sizes;
        var image = new Image();
        image.src = src;

        if (srcset) {
            image.srcset = srcset;
        }

        if (sizes) {
            image.sizes = sizes;
        }

        if ('decode' in image) {
            return new Promise(function (resolve, reject) {
                var _this4 = this;

                _newArrowCheck(this, _this3);

                image.decode().then(function () {
                    _newArrowCheck(this, _this4);

                    resolve(image);
                }.bind(this))["catch"](function () {
                    _newArrowCheck(this, _this4);

                    reject(image);
                }.bind(this));
            }.bind(this));
        } else {
            return new Promise(function (resolve, reject) {
                _newArrowCheck(this, _this3);

                image.onload = resolve(image);
                image.onerror = reject(image);
            }.bind(this));
        }
    }
    function fit(options) {
        var height;
        var width;
        var imgHeight = options.imgHeight,
            imgWidth = options.imgWidth,
            containerHeight = options.containerHeight,
            containerWidth = options.containerWidth,
            canvasWidth = options.canvasWidth,
            canvasHeight = options.canvasHeight,
            imageSize = options.imageSize;
        var canvasRatio = canvasHeight / canvasWidth;
        var containerRatio = containerHeight / containerWidth;
        var imgRatio = imgHeight / imgWidth;

        if (imageSize == 'cover') {
            if (imgRatio < containerRatio) {
                height = containerHeight;
                width = height / imgRatio;
            } else {
                width = containerWidth;
                height = width * imgRatio;
            }
        } else if (imageSize == 'native') {
            height = imgHeight;
            width = imgWidth;
        } else {
            if (imgRatio > canvasRatio) {
                height = canvasHeight;
                width = height / imgRatio;
            } else {
                width = canvasWidth;
                height = width * imgRatio;
            }

            if (imageSize === 'scale-down' && (width >= imgWidth || height >= imgHeight)) {
                width = imgWidth;
                height = imgHeight;
            }
        }

        return {
            height: height,
            width: width
        };
    }
    function openFullScreen(wrapper) {
        if (wrapper.requestFullscreen) {
            return wrapper.requestFullscreen();
        } else if (wrapper.webkitRequestFullscreen) {
            return wrapper.webkitRequestFullscreen();
        } else if (wrapper.msRequestFullscreen) {
            return wrapper.msRequestFullscreen();
        } else {
            return Promise.reject();
        }
    }
    function exitFullScreen() {
        if (document.exitFullscreen) {
            return document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            return document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            return document.msExitFullscreen();
        } else {
            return Promise.reject();
        }
    }

    var defaults = {
        container: document.body,
        // window or element
        className: undefined,
        imageSize: 'scale-down',
        // 'scale-down', 'contain', 'cover' or 'native'
        fullScreen: false,
        loop: false,
        linkImages: true,
        setIndex: 0,
        firstImageIndex: 0,
        lastImageIndex: false,
        currentImageIndex: undefined,
        allowZoom: true,
        closeOnBackgroundClick: true,
        setTitle: function setTitle() {
            return '';
        },
        description: function description() {
            return this.images[this.settings.currentImageIndex].title;
        },
        pagination: function pagination() {
            var last = this.settings.lastImageIndex + 1;
            var position = this.settings.currentImageIndex + 1;
            return position + '/' + last;
        },
        afterInitialize: function afterInitialize() { },
        afterMarkup: function afterMarkup() { },
        afterImageLoad: function afterImageLoad() { },
        afterClose: function afterClose() { },
        zoomedPaddingX: function zoomedPaddingX(canvasWidth, imgWidth) {
            return 0;
        },
        zoomedPaddingY: function zoomedPaddingY(canvasHeight, imgHeight) {
            return 0;
        }
    };
    var Chocolat = /*#__PURE__*/function () {
        function Chocolat(elements, settings) {
            var _this = this;

            _classCallCheck(this, Chocolat);

            this.settings = settings;
            this.elems = {};
            this.images = [];
            this.events = [];
            this.state = {
                fullScreenOpen: false,
                initialZoomState: null,
                initialized: false,
                timer: false,
                visible: false
            };
            this._cssClasses = ['chocolat-open', 'chocolat-in-container', 'chocolat-cover', 'chocolat-zoomable', 'chocolat-zoomed', 'chocolat-zooming-in', 'chocolat-zooming-out'];

            if (NodeList.prototype.isPrototypeOf(elements) || HTMLCollection.prototype.isPrototypeOf(elements)) {
                elements.forEach(function (el, i) {
                    var _this2 = this;

                    _newArrowCheck(this, _this);

                    this.images.push({
                        title: el.getAttribute('title'),
                        src: el.getAttribute('href'),
                        srcset: el.getAttribute('data-srcset'),
                        sizes: el.getAttribute('data-sizes')
                    });
                    this.off(el, 'click.chocolat');
                    this.on(el, 'click.chocolat', function (e) {
                        _newArrowCheck(this, _this2);

                        this.init(i);
                        e.preventDefault();
                    }.bind(this));
                }.bind(this));
            } else {
                this.images = elements;
            }

            if (this.settings.container instanceof Element || this.settings.container instanceof HTMLElement) {
                this.elems.container = this.settings.container;
            } else {
                this.elems.container = document.body;
            }

            this.api = {
                open: function open(i) {
                    _newArrowCheck(this, _this);

                    i = parseInt(i) || 0;
                    return this.init(i);
                }.bind(this),
                close: function close() {
                    _newArrowCheck(this, _this);

                    return this.close();
                }.bind(this),
                next: function next() {
                    _newArrowCheck(this, _this);

                    return this.change(1);
                }.bind(this),
                prev: function prev() {
                    _newArrowCheck(this, _this);

                    return this.change(-1);
                }.bind(this),
                "goto": function goto(i) {
                    _newArrowCheck(this, _this);

                    return this.open(i);
                }.bind(this),
                current: function current() {
                    _newArrowCheck(this, _this);

                    return this.settings.currentImageIndex;
                }.bind(this),
                position: function position() {
                    _newArrowCheck(this, _this);

                    return this.position(this.elems.img);
                }.bind(this),
                destroy: function destroy() {
                    _newArrowCheck(this, _this);

                    return this.destroy();
                }.bind(this),
                set: function set(property, value) {
                    _newArrowCheck(this, _this);

                    this.settings[property] = value;
                    return value;
                }.bind(this),
                get: function get(property) {
                    _newArrowCheck(this, _this);

                    return this.settings[property];
                }.bind(this),
                getElem: function getElem(name) {
                    _newArrowCheck(this, _this);

                    return this.elems[name];
                }.bind(this)
            };
        }

        _createClass(Chocolat, [{
            key: "init",
            value: function init(i) {
                if (!this.state.initialized) {
                    this.markup();
                    this.attachListeners();
                    this.settings.lastImageIndex = this.images.length - 1;
                    this.state.initialized = true;
                }

                this.settings.afterInitialize.call(this);
                return this.load(i);
            }
        }, {
            key: "load",
            value: function load(index) {
                var _this3 = this;

                if (!this.state.visible) {
                    this.state.visible = true;
                    setTimeout(function () {
                        _newArrowCheck(this, _this3);

                        this.elems.overlay.classList.add('chocolat-visible');
                        this.elems.wrapper.classList.add('chocolat-visible');
                    }.bind(this), 0);
                    this.elems.container.classList.add('chocolat-open');
                }

                if (this.settings.fullScreen) {
                    openFullScreen(this.elems.wrapper);
                }

                if (this.settings.currentImageIndex === index) {
                    return Promise.resolve();
                }

                var loaderTimer = setTimeout(function () {
                    _newArrowCheck(this, _this3);

                    this.elems.loader.classList.add('chocolat-visible');
                }.bind(this), 1000);
                var fadeOutPromise;
                var image;
                var fadeOutTimer = setTimeout(function () {
                    var _this4 = this;

                    _newArrowCheck(this, _this3);

                    fadeOutTimer = undefined;
                    fadeOutPromise = transitionAsPromise(function () {
                        _newArrowCheck(this, _this4);

                        this.elems.imageCanvas.classList.remove('chocolat-visible');
                    }.bind(this), this.elems.imageCanvas);
                }.bind(this), 80);
                return loadImage(this.images[index]).then(function (loadedImage) {
                    _newArrowCheck(this, _this3);

                    image = loadedImage;

                    if (fadeOutTimer) {
                        clearTimeout(fadeOutTimer);
                        return Promise.resolve();
                    } else {
                        return fadeOutPromise;
                    }
                }.bind(this)).then(function () {
                    var _this5 = this;

                    _newArrowCheck(this, _this3);

                    var nextIndex = index + 1;

                    if (this.images[nextIndex] != undefined) {
                        loadImage(this.images[nextIndex]);
                    }

                    this.settings.currentImageIndex = index;
                    this.elems.description.textContent = this.settings.description.call(this);
                    this.elems.pagination.textContent = this.settings.pagination.call(this);
                    this.arrows();
                    return this.position(image).then(function () {
                        _newArrowCheck(this, _this5);

                        this.elems.loader.classList.remove('chocolat-visible');
                        clearTimeout(loaderTimer);
                        return this.appear(image);
                    }.bind(this));
                }.bind(this)).then(function () {
                    _newArrowCheck(this, _this3);

                    this.elems.container.classList.toggle('chocolat-zoomable', this.zoomable(image, this.elems.wrapper));
                    this.settings.afterImageLoad.call(this);
                }.bind(this));
            }
        }, {
            key: "position",
            value: function position(_ref) {
                var _this6 = this;

                var naturalHeight = _ref.naturalHeight,
                    naturalWidth = _ref.naturalWidth;
                var fitOptions = {
                    imgHeight: naturalHeight,
                    imgWidth: naturalWidth,
                    containerHeight: this.elems.container.clientHeight,
                    containerWidth: this.elems.container.clientWidth,
                    canvasWidth: this.elems.imageCanvas.clientWidth,
                    canvasHeight: this.elems.imageCanvas.clientHeight,
                    imageSize: this.settings.imageSize
                };

                var _fit = fit(fitOptions),
                    width = _fit.width,
                    height = _fit.height;

                return transitionAsPromise(function () {
                    _newArrowCheck(this, _this6);

                    Object.assign(this.elems.imageWrapper.style, {
                        width: width + 'px',
                        height: height + 'px'
                    });
                }.bind(this), this.elems.imageWrapper);
            }
        }, {
            key: "appear",
            value: function appear(image) {
                var _this7 = this;

                this.elems.imageWrapper.removeChild(this.elems.img);
                this.elems.img = image;
                this.elems.img.setAttribute('class', 'chocolat-img');
                this.elems.imageWrapper.appendChild(this.elems.img);
                var fadeInPromise = transitionAsPromise(function () {
                    _newArrowCheck(this, _this7);

                    this.elems.imageCanvas.classList.add('chocolat-visible');
                }.bind(this), this.elems.imageCanvas);
                return fadeInPromise;
            }
        }, {
            key: "change",
            value: function change(step) {
                if (!this.state.visible) {
                    return;
                }

                if (!this.settings.linkImages) {
                    return;
                }

                this.zoomOut();
                var requestedImage = this.settings.currentImageIndex + parseInt(step);

                if (requestedImage > this.settings.lastImageIndex) {
                    if (this.settings.loop) {
                        return this.load(this.settings.firstImageIndex);
                    }
                } else if (requestedImage < this.settings.firstImageIndex) {
                    if (this.settings.loop) {
                        return this.load(this.settings.lastImageIndex);
                    }
                } else {
                    return this.load(requestedImage);
                }
            }
        }, {
            key: "arrows",
            value: function arrows() {
                if (this.settings.loop) {
                    this.elems.left.classList.add('active');
                    this.elems.right.classList.add('active');
                } else if (this.settings.linkImages) {
                    this.elems.right.classList.toggle('active', this.settings.currentImageIndex !== this.settings.lastImageIndex);
                    this.elems.left.classList.toggle('active', this.settings.currentImageIndex !== this.settings.firstImageIndex);
                } else {
                    this.elems.left.classList.remove('active');
                    this.elems.right.classList.remove('active');
                }
            }
        }, {
            key: "close",
            value: function close() {
                var _this8 = this;

                if (this.state.fullScreenOpen) {
                    exitFullScreen();
                    return;
                }

                this.state.visible = false;
                var promiseOverlay = transitionAsPromise(function () {
                    _newArrowCheck(this, _this8);

                    this.elems.overlay.classList.remove('chocolat-visible');
                }.bind(this), this.elems.overlay);
                var promiseWrapper = transitionAsPromise(function () {
                    _newArrowCheck(this, _this8);

                    this.elems.wrapper.classList.remove('chocolat-visible');
                }.bind(this), this.elems.wrapper);
                return Promise.all([promiseOverlay, promiseWrapper]).then(function () {
                    _newArrowCheck(this, _this8);

                    this.elems.container.classList.remove('chocolat-open');
                    this.settings.afterClose.call(this);
                }.bind(this));
            }
        }, {
            key: "destroy",
            value: function destroy() {
                var _this$elems$container;

                for (var i = this.events.length - 1; i >= 0; i--) {
                    var _this$events$i = this.events[i],
                        element = _this$events$i.element,
                        eventName = _this$events$i.eventName;
                    this.off(element, eventName);
                }

                if (!this.state.initialized) {
                    return;
                }

                if (this.state.fullScreenOpen) {
                    exitFullScreen();
                }

                this.settings.currentImageIndex = undefined;
                this.state.visible = false;
                this.state.initialized = false;

                (_this$elems$container = this.elems.container.classList).remove.apply(_this$elems$container, _toConsumableArray(this._cssClasses));

                this.elems.wrapper.parentNode.removeChild(this.elems.wrapper);
            }
        }, {
            key: "markup",
            value: function markup() {
                this.elems.container.classList.add('chocolat-open', this.settings.className);

                if (this.settings.imageSize == 'cover') {
                    this.elems.container.classList.add('chocolat-cover');
                }

                if (this.elems.container !== document.body) {
                    this.elems.container.classList.add('chocolat-in-container');
                }

                this.elems.wrapper = document.createElement('div');
                this.elems.wrapper.setAttribute('id', 'chocolat-content-' + this.settings.setIndex);
                this.elems.wrapper.setAttribute('class', 'chocolat-wrapper');
                this.elems.container.appendChild(this.elems.wrapper);
                this.elems.overlay = document.createElement('div');
                this.elems.overlay.setAttribute('class', 'chocolat-overlay');
                this.elems.wrapper.appendChild(this.elems.overlay);
                this.elems.loader = document.createElement('div');
                this.elems.loader.setAttribute('class', 'chocolat-loader');
                this.elems.wrapper.appendChild(this.elems.loader);
                this.elems.layout = document.createElement('div');
                this.elems.layout.setAttribute('class', 'chocolat-layout');
                this.elems.wrapper.appendChild(this.elems.layout);
                this.elems.top = document.createElement('div');
                this.elems.top.setAttribute('class', 'chocolat-top');
                this.elems.layout.appendChild(this.elems.top);
                this.elems.center = document.createElement('div');
                this.elems.center.setAttribute('class', 'chocolat-center');
                this.elems.layout.appendChild(this.elems.center);
                this.elems.left = document.createElement('div');
                this.elems.left.setAttribute('class', 'chocolat-left');
                this.elems.center.appendChild(this.elems.left);
                this.elems.imageCanvas = document.createElement('div');
                this.elems.imageCanvas.setAttribute('class', 'chocolat-image-canvas');
                this.elems.center.appendChild(this.elems.imageCanvas);
                this.elems.imageWrapper = document.createElement('div');
                this.elems.imageWrapper.setAttribute('class', 'chocolat-image-wrapper');
                this.elems.imageCanvas.appendChild(this.elems.imageWrapper);
                this.elems.img = document.createElement('img');
                this.elems.img.setAttribute('class', 'chocolat-img');
                this.elems.imageWrapper.appendChild(this.elems.img);
                this.elems.right = document.createElement('div');
                this.elems.right.setAttribute('class', 'chocolat-right');
                this.elems.center.appendChild(this.elems.right);
                this.elems.bottom = document.createElement('div');
                this.elems.bottom.setAttribute('class', 'chocolat-bottom');
                this.elems.layout.appendChild(this.elems.bottom);
                this.elems.close = document.createElement('span');
                this.elems.close.setAttribute('class', 'chocolat-close');
                this.elems.top.appendChild(this.elems.close);
                this.elems.description = document.createElement('span');
                this.elems.description.setAttribute('class', 'chocolat-description');
                this.elems.bottom.appendChild(this.elems.description);
                this.elems.pagination = document.createElement('span');
                this.elems.pagination.setAttribute('class', 'chocolat-pagination');
                this.elems.bottom.appendChild(this.elems.pagination);
                this.elems.setTitle = document.createElement('span');
                this.elems.setTitle.setAttribute('class', 'chocolat-set-title');
                this.elems.setTitle.textContent = this.settings.setTitle();
                this.elems.bottom.appendChild(this.elems.setTitle);
                this.elems.fullscreen = document.createElement('span');
                this.elems.fullscreen.setAttribute('class', 'chocolat-fullscreen');
                this.elems.bottom.appendChild(this.elems.fullscreen);
                this.settings.afterMarkup.call(this);
            }
        }, {
            key: "attachListeners",
            value: function attachListeners() {
                var _this9 = this;

                this.off(document, 'keydown.chocolat');
                this.on(document, 'keydown.chocolat', function (e) {
                    _newArrowCheck(this, _this9);

                    if (this.state.initialized) {
                        if (e.keyCode == 37) {
                            this.change(-1);
                        } else if (e.keyCode == 39) {
                            this.change(1);
                        } else if (e.keyCode == 27) {
                            this.close();
                        }
                    }
                }.bind(this));
                var right = this.elems.wrapper.querySelector('.chocolat-right');
                this.off(right, 'click.chocolat');
                this.on(right, 'click.chocolat', function () {
                    _newArrowCheck(this, _this9);

                    this.change(+1);
                }.bind(this));
                var left = this.elems.wrapper.querySelector('.chocolat-left');
                this.off(left, 'click.chocolat');
                this.on(left, 'click.chocolat', function () {
                    _newArrowCheck(this, _this9);

                    this.change(-1);
                }.bind(this));
                this.off(this.elems.close, 'click.chocolat');
                this.on(this.elems.close, 'click.chocolat', this.close.bind(this));
                this.off(this.elems.fullscreen, 'click.chocolat');
                this.on(this.elems.fullscreen, 'click.chocolat', function () {
                    _newArrowCheck(this, _this9);

                    if (this.state.fullScreenOpen) {
                        exitFullScreen();
                        return;
                    }

                    openFullScreen(this.elems.wrapper);
                }.bind(this));
                this.off(document, 'fullscreenchange.chocolat');
                this.on(document, 'fullscreenchange.chocolat', function () {
                    _newArrowCheck(this, _this9);

                    if (document.fullscreenElement || document.webkitCurrentFullScreenElement || document.webkitFullscreenElement) {
                        this.state.fullScreenOpen = true;
                    } else {
                        this.state.fullScreenOpen = false;
                    }
                }.bind(this));
                this.off(document, 'webkitfullscreenchange.chocolat');
                this.on(document, 'webkitfullscreenchange.chocolat', function () {
                    _newArrowCheck(this, _this9);

                    if (document.fullscreenElement || document.webkitCurrentFullScreenElement || document.webkitFullscreenElement) {
                        this.state.fullScreenOpen = true;
                    } else {
                        this.state.fullScreenOpen = false;
                    }
                }.bind(this));

                if (this.settings.closeOnBackgroundClick) {
                    this.off(this.elems.overlay, 'click.chocolat');
                    this.on(this.elems.overlay, 'click.chocolat', this.close.bind(this));
                }

                this.off(this.elems.wrapper, 'click.chocolat');
                this.on(this.elems.wrapper, 'click.chocolat', function () {
                    var _this10 = this;

                    _newArrowCheck(this, _this9);

                    if (this.state.initialZoomState === null || !this.state.visible) {
                        return;
                    }

                    this.elems.container.classList.add('chocolat-zooming-out');
                    this.zoomOut().then(function () {
                        _newArrowCheck(this, _this10);

                        this.elems.container.classList.remove('chocolat-zoomed');
                        this.elems.container.classList.remove('chocolat-zooming-out');
                    }.bind(this));
                }.bind(this));
                this.off(this.elems.imageWrapper, 'click.chocolat');
                this.on(this.elems.imageWrapper, 'click.chocolat', function (e) {
                    var _this11 = this;

                    _newArrowCheck(this, _this9);

                    if (this.state.initialZoomState === null && this.elems.container.classList.contains('chocolat-zoomable')) {
                        e.stopPropagation();
                        this.elems.container.classList.add('chocolat-zooming-in');
                        this.zoomIn(e).then(function () {
                            _newArrowCheck(this, _this11);

                            this.elems.container.classList.add('chocolat-zoomed');
                            this.elems.container.classList.remove('chocolat-zooming-in');
                        }.bind(this));
                    }
                }.bind(this));
                this.on(this.elems.wrapper, 'mousemove.chocolat', function (e) {
                    _newArrowCheck(this, _this9);

                    if (this.state.initialZoomState === null || !this.state.visible) {
                        return;
                    }

                    var rect = this.elems.wrapper.getBoundingClientRect();
                    var pos = {
                        top: rect.top + window.scrollY,
                        left: rect.left + window.scrollX
                    };
                    var height = this.elems.wrapper.clientHeight;
                    var width = this.elems.wrapper.clientWidth;
                    var imgWidth = this.elems.img.width;
                    var imgHeight = this.elems.img.height;
                    var coord = [e.pageX - width / 2 - pos.left, e.pageY - height / 2 - pos.top];
                    var mvtX = 0;

                    if (imgWidth > width) {
                        var paddingX = this.settings.zoomedPaddingX(imgWidth, width);
                        mvtX = coord[0] / (width / 2);
                        mvtX = ((imgWidth - width) / 2 + paddingX) * mvtX;
                    }

                    var mvtY = 0;

                    if (imgHeight > height) {
                        var paddingY = this.settings.zoomedPaddingY(imgHeight, height);
                        mvtY = coord[1] / (height / 2);
                        mvtY = ((imgHeight - height) / 2 + paddingY) * mvtY;
                    }

                    this.elems.img.style.marginLeft = -mvtX + 'px';
                    this.elems.img.style.marginTop = -mvtY + 'px';
                }.bind(this));
                this.on(window, 'resize.chocolat', function (e) {
                    var _this12 = this;

                    _newArrowCheck(this, _this9);

                    if (!this.state.initialized || !this.state.visible) {
                        return;
                    }

                    debounce(50, function () {
                        var _this13 = this;

                        _newArrowCheck(this, _this12);

                        var fitOptions = {
                            imgHeight: this.elems.img.naturalHeight,
                            imgWidth: this.elems.img.naturalWidth,
                            containerHeight: this.elems.wrapper.clientHeight,
                            containerWidth: this.elems.wrapper.clientWidth,
                            canvasWidth: this.elems.imageCanvas.clientWidth,
                            canvasHeight: this.elems.imageCanvas.clientHeight,
                            imageSize: this.settings.imageSize
                        };

                        var _fit2 = fit(fitOptions);

                        this.position(this.elems.img).then(function () {
                            _newArrowCheck(this, _this13);

                            this.elems.container.classList.toggle('chocolat-zoomable', this.zoomable(this.elems.img, this.elems.wrapper));
                        }.bind(this));
                    }.bind(this));
                }.bind(this));
            }
        }, {
            key: "zoomable",
            value: function zoomable(image, wrapper) {
                var wrapperWidth = wrapper.clientWidth;
                var wrapperHeight = wrapper.clientHeight;
                var isImageZoomable = this.settings.allowZoom && (image.naturalWidth > wrapperWidth || image.naturalHeight > wrapperHeight) ? true : false;
                var isImageStretched = image.clientWidth > image.naturalWidth || image.clientHeight > image.naturalHeight;
                return isImageZoomable && !isImageStretched;
            }
        }, {
            key: "zoomIn",
            value: function zoomIn(e) {
                this.state.initialZoomState = this.settings.imageSize;
                this.settings.imageSize = 'native';
                return this.position(this.elems.img);
            }
        }, {
            key: "zoomOut",
            value: function zoomOut(e) {
                this.settings.imageSize = this.state.initialZoomState || this.settings.imageSize;
                this.state.initialZoomState = null;
                this.elems.img.style.margin = 0;
                return this.position(this.elems.img);
            }
        }, {
            key: "on",
            value: function on(element, eventName, cb) {
                // const eventName = this.settings.setIndex + '-' + eventName
                var length = this.events.push({
                    element: element,
                    eventName: eventName,
                    cb: cb
                });
                element.addEventListener(eventName.split('.')[0], this.events[length - 1].cb);
            }
        }, {
            key: "off",
            value: function off(element, eventName) {
                var _this14 = this;

                // const eventName = this.settings.setIndex + '-' + eventName
                var index = this.events.findIndex(function (event) {
                    _newArrowCheck(this, _this14);

                    return event.element === element && event.eventName === eventName;
                }.bind(this));

                if (this.events[index]) {
                    element.removeEventListener(eventName.split('.')[0], this.events[index].cb);
                    this.events.splice(index, 1);
                }
            }
        }]);

        return Chocolat;
    }();

    var instances = [];

    window.Chocolat = function (elements, options) {
        var settings = Object.assign({}, defaults, {
            images: []
        }, options, {
            setIndex: instances.length
        });
        var instance = new Chocolat(elements, settings);
        instances.push(instance);
        return instance;
    };

}());
